<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>UNDRA ENGINE v1.1</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #111;
      color: #eee;
    }
    h1,h2,h3 {
      color:#f5e6b3;
    }
    .container {
      max-width: 1280px;
      margin: 0 auto;
      padding: 16px;
    }
    .steps-nav {
      display:flex;
      gap:8px;
      margin-bottom:12px;
    }
    .steps-nav button {
      flex:1;
      padding:8px;
      background:#222;
      color:#eee;
      border:1px solid #555;
      cursor:pointer;
    }
    .steps-nav button.active {
      background:#444;
      border-color:#d4af37;
      color:#fff;
    }
    .step {
      display:none;
      border:1px solid #333;
      padding:12px;
      border-radius:4px;
      background:#181818;
      margin-bottom:16px;
    }
    .step.active { display:block; }
    .flex { display:flex; gap:16px; }
    .column { flex:1; min-width:0; }
    .attr-row, .skill-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:4px;
    }
    .val-box {
      min-width:32px;
      text-align:center;
      padding:2px 4px;
      border:1px solid #555;
      border-radius:3px;
      background:#222;
      color:#f5e6b3;
    }
    .btn, .btn-upgrade {
      padding:4px 8px;
      background:#333;
      border:1px solid #777;
      color:#eee;
      cursor:pointer;
      border-radius:3px;
      font-size:12px;
    }
    .btn.primary {
      background:#d4af37;
      color:#111;
      border-color:#f5e6b3;
    }
    .portrait-box, .final-portrait-box {
      width:180px;
      height:220px;
      border:1px solid #555;
      background:#000;
      display:flex;
      justify-content:center;
      align-items:center;
      overflow:hidden;
    }
    .portrait-box img,
    .final-portrait-box img {
      max-width:100%;
      max-height:100%;
    }
    canvas {
      background:#000;
      border:1px solid #555;
    }
    textarea {
      width:100%;
      min-height:100px;
      background:#111;
      color:#eee;
      border:1px solid #555;
      border-radius:3px;
      padding:4px;
      font-size:12px;
    }
    input, select {
      background:#111;
      color:#eee;
      border:1px solid #555;
      border-radius:3px;
      padding:3px;
      font-size:12px;
    }
    .small-label {
      font-size:11px;
      color:#aaa;
    }
    .dice-box {
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-bottom:6px;
    }
    .dice-btn {
      padding:6px 8px;
      font-size:13px;
      background:#222;
      color:#f5e6b3;
      border:1px solid #d4af37;
      border-radius:4px;
      cursor:pointer;
    }
    #last-roll {
      font-size:12px;
      margin-bottom:8px;
    }
    .history-box,
    .timeline-box,
    .skills-list,
    #combat-log,
    #travel-log,
    #quest-log,
    #merchant-log,
    #rest-log,
    #status-log,
    #money-history {
      max-height:220px;
      overflow-y:auto;
      border:1px solid #333;
      padding:6px;
      background:#101010;
      font-size:12px;
    }
    .history-entry, .timeline-entry { margin-bottom:3px; }
    .inv-grid { display:grid; gap:4px; }
    .inv-slot {
      display:flex;
      align-items:center;
      gap:4px;
      border:1px solid #333;
      padding:2px 4px;
    }
    .inv-icon { width:20px; text-align:center; }
    .tag {
      display:inline-block;
      padding:2px 6px;
      margin:2px;
      border-radius:3px;
      border:1px solid #555;
      font-size:11px;
      cursor:pointer;
    }
    .tag.selected {
      background:#d4af37;
      color:#111;
      border-color:#f5e6b3;
    }
    .top-bar {
      display:flex;
      justify-content:space-between;
      margin-bottom:8px;
      font-size:12px;
    }
    .hidden { display:none !important; }
    .modal-backdrop {
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.7);
      display:none;
      justify-content:center;
      align-items:center;
      z-index:1000;
    }
    .modal {
      background:#181818;
      border:1px solid #555;
      padding:16px;
      border-radius:4px;
      max-width:380px;
      width:90%;
      color:#eee;
      font-size:13px;
    }
    .row { margin-bottom:6px; }
    .currency-display, .sp-display {
      margin-bottom:4px;
      font-size:13px;
    }
    #combat-ui.hidden { display:none; }
    .status-icon {
      width:20px;
      height:20px;
      border-radius:50%;
      border:1px solid #555;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      margin-right:4px;
      cursor:pointer;
    }
    .ability-row {
      border-bottom:1px solid #333;
      padding:4px 0;
      font-size:12px;
    }
    .ability-name.learned { color:#d4af37; }
    .merchant-slot {
      display:flex;
      align-items:center;
      gap:4px;
      border:1px solid #333;
      padding:2px 4px;
      margin-bottom:2px;
    }
    #rest-dropdown { position:relative; }
    #rest-dropdown-menu {
      position:absolute;
      top:100%;
      left:0;
      background:#222;
      border:1px solid #555;
      padding:4px;
      z-index:500;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>UNDRA ENGINE v1.1</h1>
  <div class="top-bar">
    <div>Version: <span id="version-tag">1.1</span></div>
    <div>Aktueller Tag: <span id="day-display">1</span></div>
  </div>

  <div class="steps-nav">
    <button id="nav-step-1" class="active" onclick="toStep(1)">STEP 1 – Ursprung</button>
    <button id="nav-step-2" onclick="toStep(2)">STEP 2 – Entscheidungen</button>
    <button id="nav-step-3" onclick="toStep(3)">STEP 3 – Aventur</button>
  </div>

  <!-- STEP 1 -->
  <div id="step-1" class="step active">
    <div class="flex">
      <div class="column">
        <h2>Portrait & Basisdaten</h2>
        <div class="portrait-box">
          <img id="preview" alt="Portrait">
        </div>
        <div class="row">
          <input type="file" id="portrait-input" accept="image/*">
        </div>
        <div class="row">
          <label class="small-label">Name:</label>
          <input type="text" id="char-name" placeholder="Name">
        </div>
        <div class="row">
          <label class="small-label">Rasse:</label>
          <select id="race-select"></select>
        </div>
        <div class="row">
          <label class="small-label">Profession:</label>
          <select id="profession-select"></select>
        </div>
        <div class="row">
          <button class="btn" onclick="openSpecialModal()">Spezialfähigkeit</button>
        </div>
      </div>

      <div class="column">
        <h2>Attribute</h2>
        <div id="attr-grid"></div>
        <div class="row">
          <button class="btn" onclick="randomizeAttributes()">Attribute würfeln</button>
        </div>
        <h3>Attribut-Radar</h3>
        <canvas id="attrRadar" width="260" height="260"></canvas>
      </div>

      <div class="column">
        <h2>Chronik – Ursprung</h2>
        <textarea id="origin-text" placeholder="Beschreibe Ursprung, Kindheit, Herkunft..."></textarea>
        <div class="row">
          <button class="btn primary" onclick="toStep(2)">Weiter zu STEP 2</button>
        </div>
      </div>
    </div>
  </div>

  <!-- STEP 2 -->
  <div id="step-2" class="step">
    <div class="flex">
      <div class="column">
        <h2>Vorteile</h2>
        <div id="vorteile-list"></div>
      </div>
      <div class="column">
        <h2>Nachteile</h2>
        <div id="nachteile-list"></div>
      </div>
      <div class="column">
        <h2>Chronik – Entscheidungen</h2>
        <textarea id="chronik-text" placeholder="Entscheidungen, Wendepunkte, Verluste, Schwüre..."></textarea>
        <div class="row small-label" id="vn-status"></div>
        <div class="row">
          <button class="btn" onclick="toStep(1)">Zurück zu STEP 1</button>
          <button class="btn primary" id="finish-step-2-btn" disabled onclick="toStep(3)">Erstellung abschließen</button>
        </div>
        <h3>Entscheidungs-Radar</h3>
        <canvas id="chronikRadar" width="260" height="260"></canvas>
      </div>
    </div>
  </div>

  <!-- STEP 3 -->
  <div id="step-3" class="step">
    <div class="flex">
      <div class="column">
        <h2>Finalportrait & Vitalwerte</h2>
        <div class="final-portrait-box">
          <img id="final-portrait" alt="Finalportrait">
        </div>
        <div class="row">
          LE: <span id="calc-le-val">0</span> |
          EN: <span id="calc-en-val">0</span> |
          RS: <span id="calc-rs-val">0</span> |
          GG: <span id="calc-gg-val">0</span> |
          TC: <span id="calc-tc-val">0</span>
        </div>
        <h3>Final-Radar</h3>
        <canvas id="finalRadar" width="260" height="260"></canvas>
        <div class="row">
          <span class="small-label">Leben: <span id="life-current"></span>/<span id="life-max"></span></span><br>
          <span class="small-label">Ausdauer: <span id="stamina-current"></span>/<span id="stamina-max"></span></span>
        </div>
        <div class="row small-label">
          Rüstungspuffer: <span id="armor-buffer">0</span>
          <button class="btn" onclick="upgradeArmorBuffer()">Puffer steigern</button>
        </div>
        <div class="row small-label">
          Trefferzone: <span id="zone-info-name"></span> – <span id="zone-info-state"></span>
        </div>
      </div>

      <div class="column">
        <h2>Aktive Attribute & Würfel</h2>
        <div class="row small-label">Tagespunkte: <span id="daily-points-display">0</span></div>
        <div id="active-attr-grid"></div>
        <h3>Würfel</h3>
        <div id="dice-box" class="dice-box"></div>
        <div id="last-roll">Noch kein Wurf</div>
        <div class="row">
          <button class="btn" onclick="playerAttack()">Angriff</button>
          <button class="btn" onclick="playerDefend()">Verteidigung</button>
          <button class="btn" onclick="playerDodge()">Ausweichen</button>
        </div>
        <div class="row">
          <button class="btn" onclick="openProbePopup()">Probe</button>
          <button class="btn" onclick="openEnemyLevelMenu()">Gegner erzeugen</button>
        </div>
        <div class="row small-label">
          <div id="combat-ui" class="hidden">
            Gegner: <span id="enemy-name">—</span> |
            LP: <span id="enemy-life">-</span>
          </div>
        </div>
        <h3>Kampf-Log</h3>
        <div id="combat-log"></div>
      </div>

      <div class="column">
        <h2>Inventar & Tag</h2>
        <div class="currency-display">
          Währung: <span id="currency-display">0 G 0 S 0 K</span>
        </div>
        <div class="sp-display">
          SP: <span id="sp-display">0</span>
        </div>
        <h3>Inventar</h3>
        <div class="inv-grid">
          <div>
            <strong>Klein</strong>
            <div id="inv-small"></div>
          </div>
          <div>
            <strong>Mittel</strong>
            <div id="inv-medium"></div>
          </div>
          <div>
            <strong>Groß</strong>
            <div id="inv-large"></div>
          </div>
        </div>
        <h3>Ausrüstung</h3>
        <div class="row small-label">
          Waffe: <span id="equip-weapon">—</span>
          <button class="btn" onclick="unequipItem('weapon')">Ablegen</button>
        </div>
        <div class="row small-label">
          Rüstung: <span id="equip-armor">—</span>
          <button class="btn" onclick="unequipItem('armor')">Ablegen</button>
        </div>
        <div class="row">
          <button class="btn" onclick="openSellPopup('small',0)">Verkauf / Test</button>
        </div>
        <div class="row">
          <button class="btn primary" onclick="endDay()">Tag beenden</button>
        </div>
        <h3>Timeline (Tage)</h3>
        <div id="timeline-box" class="timeline-box"></div>
      </div>
    </div>

    <div class="flex" style="margin-top:16px;">
      <div class="column">
        <h2>Historie</h2>
        <div id="history-box" class="history-box"></div>
      </div>
      <div class="column">
        <h2>Skills & Fähigkeiten</h2>
        <h4>Kompetenz-Fähigkeiten</h4>
        <div class="skills-list" id="skills-list"></div>
        <h4>Modul-8-Kampf-Fähigkeiten</h4>
        <div id="ability-list" class="skills-list"></div>
        <h4>Seite-3-Fähigkeiten (Modul 16)</h4>
        <div class="skills-list">
          <div><strong>Basis</strong></div>
          <div id="abilities-basic"></div>
          <div><strong>Rasse</strong></div>
          <div id="abilities-race"></div>
          <div><strong>Profession</strong></div>
          <div id="abilities-profession"></div>
          <div class="small-label">Verfügbare SP: <span id="abilities-sp-available">0</span></div>
          <div id="ability-log"></div>
        </div>
      </div>
      <div class="column">
        <h2>Reise / Quests / Status / Ruhe</h2>
        <h4>Reise</h4>
        <button class="btn" onclick="openTravelMenu()">Reise starten</button>
        <div id="travel-log"></div>
        <h4>Quests</h4>
        <button class="btn" onclick="openQuestCompletePopup()">Quest abschließen (Code)</button>
        <button class="btn" onclick="openQuestRewardPopup()">Quest-Belohnung einlösen</button>
        <div id="quest-log"></div>
        <h4>Status-Effekte</h4>
        <div id="status-effects"></div>
        <div id="status-log"></div>
        <h4>Rast</h4>
        <div id="rest-dropdown">
          <button class="btn" onclick="openRestDropdown()">Rasten</button>
          <div id="rest-dropdown-menu" class="hidden">
            <button class="btn" onclick="restShort()">Kurze Rast</button>
            <button class="btn" onclick="restCamp()">Lager errichten</button>
            <button class="btn" onclick="openOvernightOptions()">Übernachtung</button>
          </div>
        </div>
        <div id="rest-log"></div>
        <h4>Buffs</h4>
        <div id="buff-list"></div>
      </div>
    </div>
  </div>
</div>

<!-- SPEZIALFÄHIGKEIT -->
<div id="special-modal" class="modal-backdrop">
  <div class="modal">
    <h3>Spezialfähigkeit</h3>
    <div id="special-content"></div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeSpecialModal()">Schließen</button>
    </div>
  </div>
</div>

<!-- DANKES-MODAL / TAG BEENDEN -->
<div id="thanks-modal" class="modal-backdrop">
  <div class="modal">
    <h3>Tag beendet</h3>
    <div id="thanks-text"></div>
    <div class="row" style="text-align:right;">
      <button class="btn primary" onclick="closeThanks()">Weiter</button>
    </div>
  </div>
</div>

<!-- REPARATUR POPUP (Rüstungspuffer/Zone) -->
<div id="popup-armor-repair" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Rüstungsreparatur</h3>
    <div id="popup-armor-text"></div>
    <div class="row">
      <button id="btn-repair-gold" class="btn">Mit Gold reparieren</button>
      <button id="btn-repair-sp" class="btn">Mit SP reparieren</button>
    </div>
    <div class="row" style="text-align:right;">
      <button id="btn-repair-cancel" class="btn">Abbrechen</button>
    </div>
  </div>
</div>

<!-- INVENTAR-VERKAUF POPUP -->
<div id="sell-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Item-Aktion</h3>
    <div class="row">
      <button class="btn" onclick="openSellValuePopup()">Verkaufen</button>
      <button class="btn" onclick="discardItem()">Wegwerfen</button>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeSellPopup()">Schließen</button>
    </div>
  </div>
</div>

<div id="sell-value-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Verkaufspreis</h3>
    <div class="row small-label">Gold:</div>
    <input type="number" id="sell-gold" value="0" min="0">
    <div class="row small-label">Silber:</div>
    <input type="number" id="sell-silver" value="0" min="0">
    <div class="row small-label">Kupfer:</div>
    <input type="number" id="sell-copper" value="0" min="0">
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeSellValuePopup()">Abbrechen</button>
      <button class="btn primary" onclick="confirmSell()">Verkaufen</button>
    </div>
  </div>
</div>

<!-- PROBEN-POPUP -->
<div id="probe-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Probe</h3>
    <div class="row small-label">
      Ergebnis:
    </div>
    <div id="probe-result"></div>
    <div class="row">
      <button class="btn" onclick="performAttributeProbe('IN')">IN-Probe</button>
      <button class="btn" onclick="performAttributeProbe('GE')">GE-Probe</button>
      <button class="btn" onclick="performCombinedProbe('KK','GE')">KK+GE</button>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeProbePopup()">Schließen</button>
    </div>
  </div>
</div>

<!-- GELD-HISTORIE -->
<div id="money-history" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Geld-Historie</h3>
    <div id="money-history-list"></div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeMoneyHistory()">Schließen</button>
    </div>
  </div>
</div>

<!-- GEGNER-LEVEL AUSWAHL -->
<div id="enemy-level-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Gegner-Level wählen</h3>
    <div class="row">
      <button class="btn" onclick="chooseEnemyLevel(1)">1</button>
      <button class="btn" onclick="chooseEnemyLevel(3)">3</button>
      <button class="btn" onclick="chooseEnemyLevel(5)">5</button>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeEnemyLevelMenu()">Abbrechen</button>
    </div>
  </div>
</div>

<!-- GEGNER-TYP AUSWAHL -->
<div id="enemy-type-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Gegner-Typ wählen</h3>
    <div class="row">
      <button class="btn" onclick="chooseEnemyType('humanoid')">Humanoid</button>
      <button class="btn" onclick="chooseEnemyType('beast')">Tier</button>
      <button class="btn" onclick="chooseEnemyType('undead')">Untot</button>
      <button class="btn" onclick="chooseEnemyType('demon')">Dämon</button>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeEnemyTypeMenu()">Abbrechen</button>
    </div>
  </div>
</div>

<!-- REISE-POPUPS -->
<div id="travel-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Reiseziel wählen</h3>
    <div id="travel-zone-list"></div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeTravelMenu()">Schließen</button>
    </div>
  </div>
</div>

<div id="travel-confirm-popup" class="modal-backdrop hidden" data-zone-id="">
  <div class="modal">
    <h3>Reise bestätigen</h3>
    <div class="row">
      Ziel: <span id="travel-confirm-name"></span>
    </div>
    <div class="row small-label">
      Dauer: <span id="travel-confirm-time"></span> | Gefahr: <span id="travel-confirm-danger"></span>
    </div>
    <div class="row" id="travel-confirm-desc"></div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeZoneConfirm()">Abbrechen</button>
      <button class="btn primary" onclick="confirmTravel()">Reisen</button>
    </div>
  </div>
</div>

<div id="zone-probe-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Zonenprobe</h3>
    <div id="zone-probe-desc"></div>
    <div class="row small-label">
      Attribut: <span id="zone-probe-attr"></span> – Schwierigkeit: <span id="zone-probe-diff"></span>
    </div>
    <div class="row">
      <button class="btn" onclick="performZoneEventProbe()">Probe ablegen</button>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeZoneProbePopup()">Schließen</button>
    </div>
  </div>
</div>

<!-- QUEST-CODES & BELOHNUNGEN -->
<div id="quest-complete-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Quest abgeschlossen</h3>
    <div class="row small-label">
      Notiere den Code für den DM:
    </div>
    <div class="row">
      <strong id="quest-complete-code"></strong>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeQuestCompletePopup()">Schließen</button>
    </div>
  </div>
</div>

<div id="quest-reward-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Quest-Belohnung einlösen</h3>
    <div class="row small-label">
      Code eingeben:
    </div>
    <input type="text" id="reward-code-input">
    <div class="row">
      <button class="btn" onclick="validateQuestCode()">Code prüfen</button>
    </div>
    <div id="quest-reward-fields" class="hidden">
      <div class="row small-label">Inventar-Items (IDs, Komma getrennt)</div>
      <textarea id="reward-inventory"></textarea>
      <div class="row small-label">Loot-Items (IDs, Komma getrennt)</div>
      <textarea id="reward-loot"></textarea>
      <div class="row small-label">Gold/Silber/Kupfer (z.B. 1/5/0)</div>
      <input type="text" id="reward-gold">
      <div class="row" style="text-align:right;">
        <button class="btn" onclick="resetQuestRewardFields()">Reset</button>
        <button class="btn primary" onclick="confirmQuestRewards()">Belohnung vergeben</button>
      </div>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeQuestRewardPopup()">Schließen</button>
    </div>
  </div>
</div>

<!-- HÄNDLER-POPUPS -->
<div id="merchant-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Händler: <span id="merchant-name"></span></h3>
    <div class="flex">
      <div class="column">
        <h4>Waren</h4>
        <div id="merchant-items"></div>
      </div>
      <div class="column">
        <h4>Dein Inventar</h4>
        <div id="merchant-player-items"></div>
      </div>
    </div>
    <h4>Handels-Log</h4>
    <div id="merchant-log"></div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeMerchant()">Schließen</button>
    </div>
  </div>
</div>

<div id="merchant-price-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Preis festlegen</h3>
    <div class="row small-label">Gold</div>
    <input type="number" id="merchant-price-gold" value="0">
    <div class="row small-label">Silber</div>
    <input type="number" id="merchant-price-silver" value="0">
    <div class="row small-label">Kupfer</div>
    <input type="number" id="merchant-price-copper" value="0">
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeMerchantPricePopup()">Abbrechen</button>
      <button class="btn primary" onclick="confirmMerchantTransaction()">Bestätigen</button>
    </div>
  </div>
</div>

<!-- RUHE / ÜBERNACHTUNG -->
<div id="overnight-options-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Übernachtung wählen</h3>
    <div class="row">
      <button class="btn" onclick="openOvernightPricePopup('taverne')">Taverne</button>
      <button class="btn" onclick="openOvernightPricePopup('gasthaus')">Gasthaus</button>
    </div>
    <div class="row">
      <button class="btn" onclick="openOvernightPricePopup('bordell')">Bordell</button>
      <button class="btn" onclick="openOvernightPricePopup('military')">Militärische Anlage</button>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeOvernightOptions()">Abbrechen</button>
    </div>
  </div>
</div>

<div id="overnight-price-popup" class="modal-backdrop hidden" data-type="">
  <div class="modal">
    <h3>Übernachtung bezahlen</h3>
    <div class="row small-label">Gold</div>
    <input type="number" id="overnight-gold" value="0">
    <div class="row small-label">Silber</div>
    <input type="number" id="overnight-silver" value="0">
    <div class="row small-label">Kupfer</div>
    <input type="number" id="overnight-copper" value="0">
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeOvernightPricePopup()">Abbrechen</button>
      <button class="btn primary" onclick="confirmOvernightPrice()">Bestätigen</button>
    </div>
  </div>
</div>

<!-- STATUS-DETAILS -->
<div id="status-popup" class="modal-backdrop hidden">
  <div class="modal">
    <h3 id="status-popup-name"></h3>
    <div id="status-popup-desc"></div>
    <div class="row">
      <button class="btn" onclick="removeStatusEffect()">Status entfernen</button>
    </div>
    <div class="row" style="text-align:right;">
      <button class="btn" onclick="closeStatusPopup()">Schließen</button>
    </div>
  </div>
</div>

<script>
/* ============================================================
   CORE (Schritt 1)
============================================================ */
const player = {
  name: "",
  raceId: "",
  professionId: "",
  attributes: {},
  talents: {},
  vital: {
    life: 10,
    maxLife: 10,
    stamina: 10,
    maxStamina: 10
  },
  resources: {
    SP: 0,
    AE: 0,
    SG: 0,
    gold: 0,
    silver: 0,
    copper: 0,
    totalCopper: 0
  },
  combat: {
    attack: 0,
    defense: 0,
    hitChance: 50,
    evasion: 0,
    armor: 0
  },
  armorBuffer: 0,
  inventory: {
    small: [],
    medium: [],
    large: []
  },
  equipment: {
    weapon: null,
    offhand: null,
    armor: null,
    accessory1: null,
    accessory2: null
  },
  abilities: [],
  buffs: [],
  statusEffects: [],
  questCodes: [],
  moneyHistory: [],
  traits: [],
  magicRes: 0,
  day: 1
};

Object.defineProperty(player, "hp", {
  get() {
    return {
      get current() { return player.vital.life; },
      set current(v) { player.vital.life = Math.max(0, v); },
      get max() { return player.vital.maxLife; },
      set max(v) { player.vital.maxLife = v; }
    };
  }
});

Object.defineProperty(player, "stamina", {
  get() {
    return {
      get current() { return player.vital.stamina; },
      set current(v) { player.vital.stamina = Math.max(0, v); },
      get max() { return player.vital.maxStamina; },
      set max(v) { player.vital.maxStamina = v; }
    };
  }
});

function grantSP(amount, reason = "Unbekannt") {
  player.resources.SP = (player.resources.SP || 0) + amount;
  if (player.resources.SP < 0) player.resources.SP = 0;
  updateSPUI();
  const box = document.getElementById("history-box");
  if (box) {
    const line = document.createElement("div");
    line.className = "history-entry";
    line.textContent = `SP ${amount >= 0 ? "+" : ""}${amount} (${reason})`;
    box.appendChild(line);
    box.scrollTop = box.scrollHeight;
  }
}

function updateVitalUI() {
  const lifeCur = document.getElementById("life-current");
  const lifeMax = document.getElementById("life-max");
  const stamCur = document.getElementById("stamina-current");
  const stamMax = document.getElementById("stamina-max");
  if (lifeCur) lifeCur.textContent = player.vital.life;
  if (lifeMax) lifeMax.textContent = player.vital.maxLife;
  if (stamCur) stamCur.textContent = player.vital.stamina;
  if (stamMax) stamMax.textContent = player.vital.maxStamina;
}

function updateSPUI() {
  const spDisplay = document.getElementById("sp-display");
  if (spDisplay) spDisplay.textContent = player.resources.SP;
  const spAbilities = document.getElementById("abilities-sp-available");
  if (spAbilities) spAbilities.textContent = player.resources.SP;
}

function subtractMoney(g=0,s=0,c=0,reason="Unbekannt") {
  if (typeof spendMoney === "function") {
    return spendMoney(g,s,c,reason);
  } else {
    const total = (g*10000)+(s*100)+c;
    const current = (player.resources.gold*10000)+(player.resources.silver*100)+(player.resources.copper);
    if (current < total) {
      alert("Nicht genug Geld!");
      return false;
    }
    const newTotal = current - total;
    player.resources.gold = Math.floor(newTotal/10000);
    let rest = newTotal % 10000;
    player.resources.silver = Math.floor(rest/100);
    player.resources.copper = rest % 100;
    updateMoneyUI();
    grantSP(1, reason || "Geldausgabe");
    return true;
  }
}
function updateMoneyUI() {
  const g = document.getElementById("money-gold");
  const s = document.getElementById("money-silver");
  const c = document.getElementById("money-copper");
  if (g) g.textContent = player.resources.gold || 0;
  if (s) s.textContent = player.resources.silver || 0;
  if (c) c.textContent = player.resources.copper || 0;
  const currencyDisplay = document.getElementById("currency-display");
  if (currencyDisplay) {
    currencyDisplay.textContent =
      `${player.resources.gold} G ${player.resources.silver} S ${player.resources.copper} K`;
  }
}
function updateGoldUI(){ updateMoneyUI(); }

function updatePlayerUI() {
  updateVitalUI();
  updateSPUI();
  updateMoneyUI();
  if (typeof updateArmorBufferUI === "function") {
    updateArmorBufferUI();
  }
}

function appendCombatLog(text) {
  const log = document.getElementById("combat-log");
  if (log) {
    const entry = document.createElement("div");
    entry.textContent = text;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
  } else {
    const box = document.getElementById("history-box");
    if (box) {
      const entry = document.createElement("div");
      entry.textContent = text;
      box.appendChild(entry);
      box.scrollTop = box.scrollHeight;
    }
  }
}
function appendTravelLog(text) {
  const box = document.getElementById("travel-log");
  if (!box) return;
  const line = document.createElement("div");
  line.textContent = text;
  box.appendChild(line);
  box.scrollTop = box.scrollHeight;
}
function appendStatusLog(text) {
  const box = document.getElementById("status-log");
  if (!box) return;
  const line = document.createElement("div");
  line.textContent = text;
  box.appendChild(line);
  box.scrollTop = box.scrollHeight;
}
function appendQuestLog(text) {
  const box = document.getElementById("quest-log");
  if (!box) return;
  const line = document.createElement("div");
  line.textContent = text;
  box.appendChild(line);
  box.scrollTop = box.scrollHeight;
}
function appendMerchantLog(text) {
  const box = document.getElementById("merchant-log");
  if (!box) return;
  const line = document.createElement("div");
  line.textContent = text;
  box.appendChild(line);
  box.scrollTop = box.scrollHeight;
}
function appendRestLog(text) {
  const box = document.getElementById("rest-log");
  if (!box) return;
  const line = document.createElement("div");
  line.textContent = text;
  box.appendChild(line);
  box.scrollTop = box.scrollHeight;
}
function renderStats(){ updateVitalUI(); }
function renderMoney(){ updateMoneyUI(); }
function renderBuffs() {
  const box = document.getElementById("buff-list");
  if (!box) return;
  box.innerHTML = "";
  (player.buffs||[]).forEach(buff=>{
    const line = document.createElement("div");
    line.textContent = `${buff.name} (${buff.duration} Tag)`;
    box.appendChild(line);
  });
}
if (typeof renderAll!=="function"){
  function renderAll(){ renderStats(); renderMoney(); renderBuffs(); }
}

/* ============================================================
   Module 1–5 (Schritt 2)
============================================================ */
let currentStep = 1;
function toStep(step) {
  currentStep = step;
  for (let i=1;i<=3;i++) {
    const stepEl = document.getElementById("step-"+i);
    const navEl = document.getElementById("nav-step-"+i);
    if (stepEl) stepEl.classList.toggle("active", i===step);
    if (navEl) navEl.classList.toggle("active", i===step);
  }
  if (step === 3) finalizeCharacterForStep3();
}

const RACE_DEFS = {
  "Mensch (Mittelländer)": {
    raceId: "human_mittellaender",
    special: "Anpassungsfähig: +1 auf einen beliebigen Wert."
  },
  "Mensch (Thorwaler)": {
    raceId: "human_thorwaler",
    special: "Seefahrer & Kampfesmut."
  },
  "Elf (Waldelf)": {
    raceId: "elf_waldelf",
    special: "Starke Bindung zur Natur."
  },
  "Zwerg (Gebirgszwerg)": {
    raceId: "dwarf_gebirge",
    special: "Robust und widerstandsfähig."
  }
};
const PROF_DEFS = {
  "Krieger": { professionId:"warrior", bonus:{ KK:2, VE:1 } },
  "Magier": { professionId:"mage", bonus:{ IN:2, KB:1 } },
  "Schurke": { professionId:"rogue", bonus:{ GE:2, KK:1 } },
  "Seefahrer": { professionId:"sailor", bonus:{ GE:1, IN:1 } }
};
const BASE_ATTRIBUTES = ["KK","GE","IN","KB","VE"];

function initStep1UI() {
  initRaceSelectUI();
  initProfessionSelectUI();
  initAttributeUI();
  initPortraitHandler();
}
function initRaceSelectUI() {
  const sel = document.getElementById("race-select");
  if (!sel) return;
  sel.innerHTML = "";
  Object.keys(RACE_DEFS).forEach(name=>{
    const opt=document.createElement("option");
    opt.value=name; opt.textContent=name;
    sel.appendChild(opt);
  });
  sel.addEventListener("change", onRaceChangeStep1);
  onRaceChangeStep1();
}
function onRaceChangeStep1() {
  const sel = document.getElementById("race-select");
  if (!sel) return;
  const chosen = RACE_DEFS[sel.value];
  if (!chosen) return;
  player.raceId = chosen.raceId;
  updateSpecialAbilityText(chosen.special);
}
function initProfessionSelectUI() {
  const sel = document.getElementById("profession-select");
  if (!sel) return;
  sel.innerHTML="";
  Object.keys(PROF_DEFS).forEach(name=>{
    const opt=document.createElement("option");
    opt.value=name; opt.textContent=name;
    sel.appendChild(opt);
  });
  sel.addEventListener("change", onProfessionChangeStep1);
  onProfessionChangeStep1();
}
function onProfessionChangeStep1() {
  const sel=document.getElementById("profession-select");
  if (!sel) return;
  const chosen = PROF_DEFS[sel.value];
  if (!chosen) return;
  player.professionId = chosen.professionId;
  applyProfessionBonuses();
  updateFinalStatsFromAttributes();
}
function applyProfessionBonuses() {
  const profEntry = Object.values(PROF_DEFS).find(p=>p.professionId===player.professionId);
  if (!profEntry) return;
  const bonus = profEntry.bonus || {};
  Object.keys(bonus).forEach(attr=>{
    player.attributes[attr] = (player.attributes[attr]||0) + bonus[attr];
    const el = document.getElementById("attr-"+attr);
    if (el) el.textContent = player.attributes[attr];
  });
}
function updateSpecialAbilityText(text) {
  const box = document.getElementById("special-content");
  if (box) box.textContent = text || "";
}
function openSpecialModal() {
  const m=document.getElementById("special-modal");
  if (m) m.style.display="flex";
}
function closeSpecialModal() {
  const m=document.getElementById("special-modal");
  if (m) m.style.display="none";
}

function initAttributeUI() {
  const grid = document.getElementById("attr-grid");
  if (!grid) return;
  grid.innerHTML="";
  BASE_ATTRIBUTES.forEach(attr=>{
    if (typeof player.attributes[attr]==="undefined") player.attributes[attr]=10;
    const row=document.createElement("div");
    row.className="attr-row";
    row.innerHTML=`
      <span>${attr}</span>
      <div class="val-box" id="attr-${attr}">${player.attributes[attr]}</div>
    `;
    grid.appendChild(row);
  });
  drawStep1Radar();
}
function rollDice(sides){ return Math.floor(Math.random()*sides)+1; }
function randomizeAttributes() {
  BASE_ATTRIBUTES.forEach(attr=>{
    const val = rollDice(6)+rollDice(6)+rollDice(6);
    player.attributes[attr]=val;
    const el=document.getElementById("attr-"+attr);
    if (el) el.textContent=val;
  });
  applyProfessionBonuses();
  updateFinalStatsFromAttributes();
  drawStep1Radar();
  grantSP(1,"Attribute neu gewürfelt");
}
function initPortraitHandler() {
  const input=document.getElementById("portrait-input");
  if (!input) return;
  input.addEventListener("change", handlePortraitUpload);
}
function handlePortraitUpload(e) {
  const file=e.target.files[0];
  if (!file) return;
  const reader=new FileReader();
  reader.onload=function(ev){
    const img=document.getElementById("preview");
    const final=document.getElementById("final-portrait");
    if (img) img.src=ev.target.result;
    if (final) final.src=ev.target.result;
  };
  reader.readAsDataURL(file);
}
function drawStep1Radar() {
  const canvas=document.getElementById("attrRadar");
  if (!canvas) return;
  const ctx=canvas.getContext("2d");
  const w=canvas.width, h=canvas.height;
  const cx=w/2, cy=h/2;
  const radius=Math.min(w,h)/2-20;
  ctx.clearRect(0,0,w,h);
  ctx.strokeStyle="#555"; ctx.lineWidth=1;
  const maxVal=20;
  const count=BASE_ATTRIBUTES.length;
  for (let r=0.25;r<=1.0;r+=0.25){
    ctx.beginPath();
    for (let i=0;i<count;i++){
      const angle=(Math.PI*2*i)/count - Math.PI/2;
      const x=cx+Math.cos(angle)*radius*r;
      const y=cy+Math.sin(angle)*radius*r;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath(); ctx.stroke();
  }
  ctx.beginPath();
  ctx.strokeStyle="#d4af37";
  ctx.fillStyle="rgba(212,175,55,0.3)";
  BASE_ATTRIBUTES.forEach((attr,i)=>{
    const val=player.attributes[attr]||0;
    const norm=Math.min(val/maxVal,1);
    const angle=(Math.PI*2*i)/count - Math.PI/2;
    const x=cx+Math.cos(angle)*radius*norm;
    const y=cy+Math.sin(angle)*radius*norm;
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.closePath(); ctx.stroke(); ctx.fill();
}

/* Vor-/Nachteile + Chronik */
const VORTEILE=["Mutig","Beliebt","Gebildet","Zäh","Glückskind"];
const NACHTEILE=["Verflucht","Schwach","Geächtet","Traumatisiert","Sucht"];
let chosenVorteile=new Set();
let chosenNachteile=new Set();

function initStep2UI() {
  initVorteileUI();
  initNachteileUI();
  updateVorNachStatus();
  drawChronikRadar();
}
function initVorteileUI(){
  const box=document.getElementById("vorteile-list");
  if(!box)return; box.innerHTML="";
  VORTEILE.forEach(name=>{
    const div=document.createElement("div");
    div.className="tag"; div.textContent=name;
    div.onclick=()=>toggleVorteil(name,div);
    box.appendChild(div);
  });
}
function initNachteileUI(){
  const box=document.getElementById("nachteile-list");
  if(!box)return; box.innerHTML="";
  NACHTEILE.forEach(name=>{
    const div=document.createElement("div");
    div.className="tag"; div.textContent=name;
    div.onclick=()=>toggleNachteil(name,div);
    box.appendChild(div);
  });
}
function toggleVorteil(name,el){
  if(chosenVorteile.has(name)){chosenVorteile.delete(name); el.classList.remove("selected");}
  else {chosenVorteile.add(name); el.classList.add("selected");}
  updateVorNachStatus(); drawChronikRadar();
}
function toggleNachteil(name,el){
  if(chosenNachteile.has(name)){chosenNachteile.delete(name); el.classList.remove("selected");}
  else {chosenNachteile.add(name); el.classList.add("selected");}
  updateVorNachStatus(); drawChronikRadar();
}
function updateVorNachStatus(){
  const status=document.getElementById("vn-status");
  const btn=document.getElementById("finish-step-2-btn");
  const vCount=chosenVorteile.size;
  const nCount=chosenNachteile.size;
  const valid = vCount>=2 && nCount>=3 && nCount>=vCount+1;
  if(status){
    status.textContent=`Vorteile: ${vCount} / min. 2, Nachteile: ${nCount} / min. 3, Nachteile ≥ Vorteile + 1: ${nCount>=vCount+1?'OK':'NEIN'}`;
  }
  if(btn) btn.disabled=!valid;
}
function drawChronikRadar(){
  const canvas=document.getElementById("chronikRadar");
  if(!canvas)return;
  const ctx=canvas.getContext("2d");
  const w=canvas.width,h=canvas.height,cx=w/2,cy=h/2,radius=Math.min(w,h)/2-20;
  ctx.clearRect(0,0,w,h);
  const chronikText=(document.getElementById("chronik-text")?.value||"").trim();
  const originText=(document.getElementById("origin-text")?.value||"").trim();
  const vals=[chosenVorteile.size,chosenNachteile.size,originText.length/100,chronikText.length/100];
  const maxVal=10, count=vals.length;
  ctx.strokeStyle="#444";
  for(let r=0.25;r<=1.0;r+=0.25){
    ctx.beginPath();
    for(let i=0;i<count;i++){
      const angle=(Math.PI*2*i)/count-Math.PI/2;
      const x=cx+Math.cos(angle)*radius*r;
      const y=cy+Math.sin(angle)*radius*r;
      if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
    }
    ctx.closePath();ctx.stroke();
  }
  ctx.beginPath();
  ctx.strokeStyle="#9b59b6"; ctx.fillStyle="rgba(155,89,182,0.3)";
  vals.forEach((v,i)=>{
    const norm=Math.min(v/maxVal,1);
    const angle=(Math.PI*2*i)/count-Math.PI/2;
    const x=cx+Math.cos(angle)*radius*norm;
    const y=cy+Math.sin(angle)*radius*norm;
    if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.closePath();ctx.stroke();ctx.fill();
}

/* Vitalwerte / Final-Radar / Aktive Attribute / Timeline */
function updateFinalStatsFromAttributes() {
  const KK=player.attributes.KK||0;
  const GE=player.attributes.GE||0;
  const IN=player.attributes.IN||0;
  const KB=player.attributes.KB||0;
  const VE=player.attributes.VE||0;
  player.vital.maxLife = 20 + KK + VE;
  player.vital.life = player.vital.maxLife;
  player.vital.maxStamina = 10 + GE + KB;
  player.vital.stamina = player.vital.maxStamina;
  player.combat.attack = Math.floor(KK/2)+5;
  player.combat.defense = Math.floor(VE/2)+5;
  player.combat.hitChance = 50 + Math.floor((GE+IN)/4);
  player.combat.evasion = Math.floor(GE/2);
  updateVitalUI();
  updateCombatDerivedUI();
  drawFinalRadar();
}
function updateCombatDerivedUI(){
  const le=document.getElementById("calc-le-val");
  const en=document.getElementById("calc-en-val");
  const rs=document.getElementById("calc-rs-val");
  const gg=document.getElementById("calc-gg-val");
  const tc=document.getElementById("calc-tc-val");
  if(le)le.textContent=player.vital.maxLife;
  if(en)en.textContent=player.vital.maxStamina;
  if(rs)rs.textContent=player.combat.defense;
  if(gg)gg.textContent=player.combat.evasion;
  if(tc)tc.textContent=player.combat.hitChance;
}
function drawFinalRadar(){
  const canvas=document.getElementById("finalRadar");
  if(!canvas)return;
  const ctx=canvas.getContext("2d");
  const w=canvas.width,h=canvas.height,cx=w/2,cy=h/2,radius=Math.min(w,h)/2-20;
  ctx.clearRect(0,0,w,h);
  const vals=[player.vital.maxLife,player.vital.maxStamina,player.combat.attack,player.combat.defense,player.combat.hitChance];
  const maxVal=Math.max(...vals,10),count=vals.length;
  ctx.strokeStyle="#333";
  for(let r=0.25;r<=1.0;r+=0.25){
    ctx.beginPath();
    for(let i=0;i<count;i++){
      const angle=(Math.PI*2*i)/count-Math.PI/2;
      const x=cx+Math.cos(angle)*radius*r;
      const y=cy+Math.sin(angle)*radius*r;
      if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();ctx.stroke();
  }
  ctx.beginPath();
  ctx.strokeStyle="#27ae60";ctx.fillStyle="rgba(39,174,96,0.3)";
  vals.forEach((v,i)=>{
    const norm=Math.min(v/maxVal,1);
    const angle=(Math.PI*2*i)/count-Math.PI/2;
    const x=cx+Math.cos(angle)*radius*norm;
    const y=cy+Math.sin(angle)*radius*norm;
    if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.closePath();ctx.stroke();ctx.fill();
}

let dailyPoints=0;
function initActiveAttributesUI(){
  const grid=document.getElementById("active-attr-grid");
  if(!grid)return;
  const ACTIVE=["KK","GE","IN","KB","VE"];
  grid.innerHTML="";
  ACTIVE.forEach(attr=>{
    const row=document.createElement("div");
    row.className="attr-row";
    row.innerHTML=`
      <span>${attr}</span>
      <div class="val-box" id="active-${attr}">${player.attributes[attr]||0}</div>
      <button class="btn-upgrade" onclick="upgradeActiveAttribute('${attr}')">+</button>
    `;
    grid.appendChild(row);
  });
  updateDailyPointsUI();
}
function upgradeActiveAttribute(attr){
  if(dailyPoints<=0){alert("Keine Tagespunkte mehr!");return;}
  player.attributes[attr]=(player.attributes[attr]||0)+1;
  dailyPoints-=1;
  const el=document.getElementById("active-"+attr);
  if(el)el.textContent=player.attributes[attr];
  updateDailyPointsUI();
  updateFinalStatsFromAttributes();
  drawFinalRadar();
  grantSP(1,"Aktives Attribut gesteigert");
}
function updateDailyPointsUI(){
  const el=document.getElementById("daily-points-display");
  if(el)el.textContent=dailyPoints;
}
let timeline=[];
function endDay(){
  timeline.push({day:player.day,timestamp:Date.now()});
  renderTimeline();
  player.day+=1;
  dailyPoints=1;
  updateDailyPointsUI();
  updateDayDisplay();
  if(typeof reduceBuffDurations==="function"){
    reduceBuffDurations();
    renderBuffs();
  }
  openThanksModal();
}
function renderTimeline(){
  const box=document.getElementById("timeline-box");
  if(!box)return;
  box.innerHTML="";
  timeline.forEach(entry=>{
    const div=document.createElement("div");
    div.className="timeline-entry";
    const date=new Date(entry.timestamp);
    div.textContent=`Tag ${entry.day} beendet (${date.toLocaleString()})`;
    box.appendChild(div);
  });
}
function updateDayDisplay(){
  const el=document.getElementById("day-display");
  if(el)el.textContent=player.day;
}
function openThanksModal(){
  const modal=document.getElementById("thanks-modal");
  const text=document.getElementById("thanks-text");
  if(text) text.textContent=`Tag ${player.day-1} ist beendet. Ein neuer Tag beginnt.`;
  if(modal) modal.style.display="flex";
}
function closeThanks(){
  const modal=document.getElementById("thanks-modal");
  if(modal) modal.style.display="none";
}
function finalizeCharacterForStep3(){
  const nameInput=document.getElementById("char-name");
  if(nameInput) player.name=nameInput.value.trim();
  updateFinalStatsFromAttributes();
  initActiveAttributesUI();
  if(player.day===1 && dailyPoints===0){ dailyPoints=1; updateDailyPointsUI(); }
  const src=document.getElementById("preview")?.src;
  const finalImg=document.getElementById("final-portrait");
  if(finalImg && src) finalImg.src=src;
}

/* ============================================================
   Modul 6–13 etc. (Schritt 3) – bereits integriert oben
   (Wegen Länge: hier nur Ergänzungen, Rest siehe oben im Chat)
============================================================ */

/* --- Modul 6: Treffezonen/Rüstung --- */
const ZONE_STATES=["Perfekt","Gut","Leicht beschädigt","Beschädigt","Schwer beschädigt"];
const hitzones={
  head:{name:"Kopf",stateIndex:1,repairCost:{gold:5,sp:1}},
  neck:{name:"Hals",stateIndex:0,repairCost:{gold:3,sp:1}},
  torso:{name:"Oberkörper",stateIndex:0,repairCost:{gold:4,sp:1}},
  legs:{name:"Unterkörper",stateIndex:2,repairCost:{gold:4,sp:1}},
  limbs:{name:"Gliedmaßen",stateIndex:3,repairCost:{gold:6,sp:2}}
};
player.armorBuffer=player.armorBuffer||0;
function updateArmorBufferUI(){
  const el=document.getElementById("armor-buffer");
  if(el) el.textContent=player.armorBuffer;
}
function upgradeArmorBuffer(){
  const cost=1000;
  if(player.resources.SP<cost){alert("Nicht genug SP für Rüstungspuffer!");return;}
  player.resources.SP-=cost;
  player.armorBuffer+=1;
  grantSP(1,"Upgrade: Rüstungspuffer");
  updateSPUI(); updateArmorBufferUI();
}
function worsenZone(zoneKey){
  const zone=hitzones[zoneKey];
  if(!zone)return;
  if(zone.stateIndex<ZONE_STATES.length-1) zone.stateIndex++;
}
function improveZone(zoneKey){
  const zone=hitzones[zoneKey];
  if(!zone)return;
  if(zone.stateIndex>0) zone.stateIndex--;
}
function applyHitToPlayer(damage,zoneKey){
  const zone=hitzones[zoneKey]||hitzones.torso;
  if(player.armorBuffer>0){
    player.armorBuffer-=1;
    updateArmorBufferUI();
    appendCombatLog("Rüstungspuffer absorbiert den Treffer!");
    return;
  }
  worsenZone(zoneKey);
  updateZoneUI(zoneKey);
  const oldLife=player.vital.life;
  player.vital.life=Math.max(0,player.vital.life-(damage||0));
  const loss=oldLife-player.vital.life;
  if(loss>0) grantSP(loss*2,"Lebensverlust");
  updateVitalUI();
}
function repairZoneWithGold(zoneKey){
  const zone=hitzones[zoneKey];
  if(!zone)return;
  const cost=zone.repairCost.gold;
  if(!hasMoney(cost,0,0)){alert("Nicht genug Gold!");return;}
  if(!subtractMoney(cost,0,0,"Reparatur (Gold)")) return;
  improveZone(zoneKey);
  grantSP(1,"Reparatur (Gold)");
  updateZoneUI(zoneKey);
  closeRepairPopup();
}
function repairZoneWithSP(zoneKey){
  const zone=hitzones[zoneKey];
  if(!zone)return;
  const cost=zone.repairCost.sp;
  if(player.resources.SP<cost){alert("Nicht genug SP!");return;}
  player.resources.SP-=cost;
  improveZone(zoneKey);
  grantSP(1,"Reparatur (SP)");
  updateSPUI();
  updateZoneUI(zoneKey);
  closeRepairPopup();
}
let currentRepairZone=null;
function openRepairPopup(zoneKey){
  currentRepairZone=zoneKey;
  const zone=hitzones[zoneKey];
  if(!zone)return;
  const text=document.getElementById("popup-armor-text");
  const btnG=document.getElementById("btn-repair-gold");
  const btnS=document.getElementById("btn-repair-sp");
  const popup=document.getElementById("popup-armor-repair");
  if(text) text.textContent=`${zone.name} – Zustand: ${ZONE_STATES[zone.stateIndex]}`;
  if(btnG) btnG.textContent=`Mit ${zone.repairCost.gold} Gold reparieren`;
  if(btnS) btnS.textContent=`Mit ${zone.repairCost.sp} SP reparieren`;
  if(popup) popup.classList.remove("hidden");
}
function closeRepairPopup(){
  const popup=document.getElementById("popup-armor-repair");
  if(popup) popup.classList.add("hidden");
  currentRepairZone=null;
}
function updateZoneUI(zoneKey){
  const zone=hitzones[zoneKey];
  if(!zone)return;
  const nameEl=document.getElementById("zone-info-name");
  const stateEl=document.getElementById("zone-info-state");
  if(nameEl) nameEl.textContent=zone.name;
  if(stateEl) stateEl.textContent=ZONE_STATES[zone.stateIndex];
}
document.addEventListener("DOMContentLoaded",()=>{
  const btnG=document.getElementById("btn-repair-gold");
  const btnS=document.getElementById("btn-repair-sp");
  const btnC=document.getElementById("btn-repair-cancel");
  if(btnG) btnG.addEventListener("click",()=>{ if(currentRepairZone) repairZoneWithGold(currentRepairZone); });
  if(btnS) btnS.addEventListener("click",()=>{ if(currentRepairZone) repairZoneWithSP(currentRepairZone); });
  if(btnC) btnC.addEventListener("click",closeRepairPopup);
});

/* Modul 7–13: aufgrund der Länge wurden sie oben im Chat bereits vollständig geliefert
   und sind hier in der Datei bereits integriert (gekürzt im Kommentar). */

/* ============================================================
   Modul 14 — Quest-Belohnungssystem
============================================================ */
player.questCodes = player.questCodes || [];
function generateQuestCode(){
  let code=""; for(let i=0;i<4;i++) code+=Math.floor(Math.random()*10); return code;
}
function openQuestCompletePopup(){
  const popup=document.getElementById("quest-complete-popup");
  const codeField=document.getElementById("quest-complete-code");
  const code=generateQuestCode();
  if(codeField) codeField.textContent=code;
  player.questCodes.push({code,time:Date.now()});
  appendQuestLog(`Quest abgeschlossen – Code: ${code}`);
  if(popup) popup.classList.remove("hidden");
}
function closeQuestCompletePopup(){
  const popup=document.getElementById("quest-complete-popup");
  if(popup) popup.classList.add("hidden");
}
function openQuestRewardPopup(){
  const popup=document.getElementById("quest-reward-popup");
  if(popup) popup.classList.remove("hidden");
}
function closeQuestRewardPopup(){
  const popup=document.getElementById("quest-reward-popup");
  if(popup) popup.classList.add("hidden");
}
function validateQuestCode(){
  const input=document.getElementById("reward-code-input").value.trim();
  const found=player.questCodes.find(e=>e.code===input);
  if(!found){ alert("Ungültiger Code!"); return false; }
  const fields=document.getElementById("quest-reward-fields");
  if(fields) fields.classList.remove("hidden");
  return true;
}
function confirmQuestRewards(){
  const invText=document.getElementById("reward-inventory").value.trim();
  const lootText=document.getElementById("reward-loot").value.trim();
  const goldText=document.getElementById("reward-gold").value.trim();
  if(invText.length>0){
    const items=invText.split(",").map(s=>s.trim());
    items.forEach(id=>{
      if(itemLibrary[id]) { addItem(id); appendQuestLog(`Belohnung: ${itemLibrary[id].name}`); }
      else { appendQuestLog(`Unbekanntes Item: ${id}`); }
    });
  }
  if(lootText.length>0){
    const lootItems=lootText.split(",").map(s=>s.trim());
    lootItems.forEach(id=>{
      if(itemLibrary[id]){ addItem(id); appendQuestLog(`Loot erhalten: ${itemLibrary[id].name}`); }
      else { appendQuestLog(`Unbekanntes Loot: ${id}`); }
    });
  }
  if(goldText.length>0){
    const parts=goldText.split("/").map(s=>parseInt(s.trim())||0);
    const g=parts[0]||0,s=parts[1]||0,c=parts[2]||0;
    addMoney(g,s,c,"Questbelohnung");
    appendQuestLog(`Gold erhalten: ${g}G ${s}S ${c}K`);
  }
  grantSP(1,"Questbelohnung");
  closeQuestRewardPopup();
}
function resetQuestRewardFields(){
  document.getElementById("reward-code-input").value="";
  document.getElementById("reward-inventory").value="";
  document.getElementById("reward-loot").value="";
  document.getElementById("reward-gold").value="";
  const f=document.getElementById("quest-reward-fields");
  if(f)f.classList.add("hidden");
}

/* ============================================================
   Modul 15 — Händler-/Handelssystem
============================================================ */
let currentMerchant=null;
function openMerchant(merchantData){
  currentMerchant=merchantData;
  const popup=document.getElementById("merchant-popup");
  const title=document.getElementById("merchant-name");
  if(title && currentMerchant.name) title.textContent=currentMerchant.name;
  renderMerchantInventory();
  renderPlayerInventoryForMerchant();
  if(popup) popup.classList.remove("hidden");
  grantSP(1,"Händler besucht");
}
function closeMerchant(){
  const popup=document.getElementById("merchant-popup");
  if(popup) popup.classList.add("hidden");
  currentMerchant=null;
}
function renderMerchantInventory(){
  const container=document.getElementById("merchant-items");
  if(!container||!currentMerchant)return;
  container.innerHTML="";
  currentMerchant.items.forEach((id,index)=>{
    const item=itemLibrary[id]; if(!item) return;
    const slot=document.createElement("div");
    slot.className="merchant-slot";
    slot.innerHTML=`
      <div class="inv-icon">${item.icon}</div>
      <div class="inv-name">${item.name}</div>
      <div class="inv-sell" onclick="openMerchantPricePopup('buy','${id}',${index})">🪙</div>
    `;
    container.appendChild(slot);
  });
}
function renderPlayerInventoryForMerchant(){
  const container=document.getElementById("merchant-player-items");
  if(!container)return;
  container.innerHTML="";
  ["small","medium","large"].forEach(size=>{
    player.inventory[size].forEach((entry,index)=>{
      if(!entry)return;
      const item=itemLibrary[entry.id]; if(!item)return;
      const slot=document.createElement("div");
      slot.className="merchant-slot";
      slot.innerHTML=`
        <div class="inv-icon">${item.icon}</div>
        <div class="inv-name">${item.name}</div>
        <div class="inv-sell" onclick="openMerchantPricePopup('sell','${size}',${index})">🪙</div>
      `;
      container.appendChild(slot);
    });
  });
}
let merchantTransaction={mode:null,ref:null};
function openMerchantPricePopup(mode,ref1,ref2){
  merchantTransaction.mode=mode;
  if(mode==="buy") merchantTransaction.ref=ref1;
  else if(mode==="sell") merchantTransaction.ref={size:ref1,index:ref2};
  document.getElementById("merchant-price-gold").value="";
  document.getElementById("merchant-price-silver").value="";
  document.getElementById("merchant-price-copper").value="";
  const popup=document.getElementById("merchant-price-popup");
  if(popup) popup.classList.remove("hidden");
}
function closeMerchantPricePopup(){
  const popup=document.getElementById("merchant-price-popup");
  if(popup) popup.classList.add("hidden");
  merchantTransaction.mode=null;
  merchantTransaction.ref=null;
}
function confirmMerchantTransaction(){
  const g=parseInt(document.getElementById("merchant-price-gold").value)||0;
  const s=parseInt(document.getElementById("merchant-price-silver").value)||0;
  const c=parseInt(document.getElementById("merchant-price-copper").value)||0;
  if(merchantTransaction.mode==="buy") handleMerchantBuy(merchantTransaction.ref,g,s,c);
  else if(merchantTransaction.mode==="sell") handleMerchantSell(merchantTransaction.ref.size,merchantTransaction.ref.index,g,s,c);
  closeMerchantPricePopup();
  renderMerchantInventory();
  renderPlayerInventoryForMerchant();
}
function handleMerchantBuy(itemId,g,s,c){
  if(!itemLibrary[itemId])return;
  if(!subtractMoney(g,s,c,"Kauf beim Händler")) return;
  addItem(itemId);
  appendMerchantLog(`Gekauft: ${itemLibrary[itemId].name} für ${g}G ${s}S ${c}K.`);
  grantSP(1,"Kauf beim Händler");
}
function handleMerchantSell(size,index,g,s,c){
  const entry=player.inventory[size][index];
  if(!entry)return;
  const item=itemLibrary[entry.id]; if(!item)return;
  addMoney(g,s,c,"Verkauf beim Händler");
  removeItem(size,index);
  appendMerchantLog(`Verkauft: ${item.name} für ${g}G ${s}S ${c}K.`);
  grantSP(1,"Verkauf beim Händler");
}

/* ============================================================
   Modul 16 — Fähigkeiten-System Seite 3
============================================================ */
const abilityBasicList=[ /* gekürzt: hier kannst du alle 20 Einträge aus deinem Modul einsetzen */ ];
const abilityRaceMap={};
const abilityProfessionMap={};
if(!player.abilities || typeof player.abilities!=="object"){
  player.abilities={basic:[],race:[],profession:[]};
}
function initAbilitiesForCharacter(){
  player.abilities.basic = (abilityBasicList||[]).map(a=>({id:a.id,learned:false}));
  player.abilities.race = (abilityRaceMap[player.raceId]||[]).map(a=>({id:a.id,learned:false}));
  player.abilities.profession = (abilityProfessionMap[player.professionId]||[]).map(a=>({id:a.id,learned:false}));
}
function getAbilityDefinition(id){
  let found = (abilityBasicList||[]).find(a=>a.id===id);
  if(found) return found;
  for(const raceKey in abilityRaceMap){
    found=abilityRaceMap[raceKey].find(a=>a.id===id);
    if(found) return found;
  }
  for(const profKey in abilityProfessionMap){
    found=abilityProfessionMap[profKey].find(a=>a.id===id);
    if(found) return found;
  }
  return null;
}
function learnAbility(area,index){
  const list=player.abilities[area];
  if(!list||!list[index])return;
  const entry=list[index];
  if(entry.learned) return;
  const def=getAbilityDefinition(entry.id);
  if(!def)return;
  const cost=def.cost||1;
  if(player.resources.SP<cost){alert("Zu wenig SP!");return;}
  player.resources.SP-=cost;
  grantSP(0,"Fähigkeit erlernt (SP aus Pool)");
  entry.learned=true;
  const areaName=area==="basic"?"Basisfähigkeit":area==="race"?"Rassenfähigkeit":"Professionfähigkeit";
  appendAbilityLog(`${areaName} erlernt: ${def.name} (Kosten: ${cost} SP)`);
  renderAbilitiesPage3();
}
function renderAbilitiesPage3(){
  const basicBox=document.getElementById("abilities-basic");
  const raceBox=document.getElementById("abilities-race");
  const profBox=document.getElementById("abilities-profession");
  if(!basicBox||!raceBox||!profBox)return;
  basicBox.innerHTML=""; raceBox.innerHTML=""; profBox.innerHTML="";
  (player.abilities.basic||[]).forEach((entry,index)=>{
    const def=getAbilityDefinition(entry.id); if(!def)return;
    const row=document.createElement("div");
    row.className="ability-row";
    row.innerHTML=`
      <div class="ability-name ${entry.learned?'learned':''}">${def.name}</div>
      <div class="ability-cost">SP: ${def.cost}</div>
      <div class="ability-desc">${def.description||""}</div>
      <button class="ability-btn" ${entry.learned?'disabled':''} onclick="learnAbility('basic',${index})">
        ${entry.learned?'Erlernt':'Erlernen'}
      </button>
    `;
    basicBox.appendChild(row);
  });
  (player.abilities.race||[]).forEach((entry,index)=>{
    const def=getAbilityDefinition(entry.id); if(!def)return;
    const row=document.createElement("div");
    row.className="ability-row";
    row.innerHTML=`
      <div class="ability-name ${entry.learned?'learned':''}">${def.name}</div>
      <div class="ability-cost">SP: ${def.cost}</div>
      <div class="ability-desc">${def.description||""}</div>
      <button class="ability-btn" ${entry.learned?'disabled':''} onclick="learnAbility('race',${index})">
        ${entry.learned?'Erlernt':'Erlernen'}
      </button>
    `;
    raceBox.appendChild(row);
  });
  (player.abilities.profession||[]).forEach((entry,index)=>{
    const def=getAbilityDefinition(entry.id); if(!def)return;
    const row=document.createElement("div");
    row.className="ability-row";
    row.innerHTML=`
      <div class="ability-name ${entry.learned?'learned':''}">${def.name}</div>
      <div class="ability-cost">SP: ${def.cost}</div>
      <div class="ability-desc">${def.description||""}</div>
      <button class="ability-btn" ${entry.learned?'disabled':''} onclick="learnAbility('profession',${index})">
        ${entry.learned?'Erlernt':'Erlernen'}
      </button>
    `;
    profBox.appendChild(row);
  });
  const spSpan=document.getElementById("abilities-sp-available");
  if(spSpan) spSpan.textContent=player.resources.SP;
}
function appendAbilityLog(text){
  const box=document.getElementById("ability-log");
  if(!box)return;
  const line=document.createElement("div");
  line.textContent=text;
  box.appendChild(line);
  box.scrollTop=box.scrollHeight;
}

/* ============================================================
   Modul 17 — Ruhe- & Regenerationssystem
============================================================ */
player.buffs = player.buffs || [];
function addBuff(id,name,duration,effect){
  player.buffs.push({id,name,duration,effect});
  appendRestLog(`Buff erhalten: ${name} (${duration} Tag)`);
}
function reduceBuffDurations(){
  player.buffs = player.buffs.filter(buff=>{
    buff.duration-=1;
    return buff.duration>0;
  });
}
function openRestDropdown(){
  const menu=document.getElementById("rest-dropdown-menu");
  if(menu) menu.classList.toggle("hidden");
}
function openOvernightOptions(){
  const popup=document.getElementById("overnight-options-popup");
  if(popup) popup.classList.remove("hidden");
}
function closeOvernightOptions(){
  const popup=document.getElementById("overnight-options-popup");
  if(popup) popup.classList.add("hidden");
}
function openOvernightPricePopup(type){
  const popup=document.getElementById("overnight-price-popup");
  if(popup){
    popup.dataset.type=type;
    popup.classList.remove("hidden");
  }
}
function closeOvernightPricePopup(){
  const popup=document.getElementById("overnight-price-popup");
  if(popup) popup.classList.add("hidden");
}
function regenPercent(value,percent){
  return Math.min(value.max,Math.floor(value.max*percent));
}
function fullRegen(value){
  return value.max;
}
function restShort(){
  player.hp.current = regenPercent(player.hp,0.30);
  player.stamina.current = regenPercent(player.stamina,0.30);
  appendRestLog("Kurze Rast gehalten (+30% LP, +30% Ausdauer).");
  renderAll();
}
function restCamp(){
  player.hp.current = fullRegen(player.hp);
  player.stamina.current = fullRegen(player.stamina);
  addBuff("rested","Ausgeruht",1,"+1 auf alle Proben");
  grantSP(1,"Lager errichtet");
  appendRestLog("Lager errichtet (volle Regeneration, +1 SP, Buff: Ausgeruht).");
  renderAll();
}
function confirmOvernightPrice(){
  const popup=document.getElementById("overnight-price-popup");
  const type=popup.dataset.type;
  const g=parseInt(document.getElementById("overnight-gold").value)||0;
  const s=parseInt(document.getElementById("overnight-silver").value)||0;
  const c=parseInt(document.getElementById("overnight-copper").value)||0;
  subtractMoney(g,s,c,"Übernachtung");
  applyOvernightEffects(type);
  closeOvernightPricePopup();
  closeOvernightOptions();
  renderAll();
}
function applyOvernightEffects(type){
  player.hp.current = fullRegen(player.hp);
  player.stamina.current = fullRegen(player.stamina);
  grantSP(1,"Übernachtung");
  switch(type){
    case "taverne":
      addBuff("rested","Erholt",1,"+1 auf Proben");
      appendRestLog("In einer Taverne übernachtet (Buff: Erholt, +1 SP).");
      break;
    case "gasthaus":
      addBuff("wellrested","Gut ausgeruht",1,"+1 auf alle Proben");
      appendRestLog("In einem Gasthaus übernachtet (Buff: Gut ausgeruht, +1 SP).");
      break;
    case "bordell":
      addBuff("relaxed","Entspannt",1,"+1 auf soziale Proben");
      appendRestLog("Im Bordell übernachtet (Buff: Entspannt, +1 SP).");
      break;
    case "military":
      addBuff("disciplined","Diszipliniert",1,"+1 auf Kampfproben");
      appendRestLog("In einer militärischen Anlage übernachtet (Buff: Diszipliniert, +1 SP).");
      break;
  }
}

/* ============================================================
   Modul 18 — Status-Effekte
============================================================ */
player.statusEffects = player.statusEffects || [];
let statusToRemove=null;
function addStatusEffect(effect){
  if(player.statusEffects.some(e=>e.id===effect.id)) return;
  player.statusEffects.push(effect);
  appendStatusLog(`Status erhalten: ${effect.name}`);
  renderStatusEffects();
}
function openStatusPopup(id){
  const effect=player.statusEffects.find(e=>e.id===id);
  if(!effect)return;
  statusToRemove=id;
  document.getElementById("status-popup-name").textContent=effect.name;
  document.getElementById("status-popup-desc").textContent=effect.desc;
  document.getElementById("status-popup").classList.remove("hidden");
}
function closeStatusPopup(){
  document.getElementById("status-popup").classList.add("hidden");
  statusToRemove=null;
}
function removeStatusEffect(){
  if(!statusToRemove)return;
  player.statusEffects = player.statusEffects.filter(e=>e.id!==statusToRemove);
  appendStatusLog(`Status entfernt: ${statusToRemove}`);
  statusToRemove=null;
  closeStatusPopup();
  renderStatusEffects();
}
function applyPoisonTick(){
  const effect=player.statusEffects.find(e=>e.id==="poison");
  if(!effect)return;
  const dmg=Math.floor(player.hp.max*0.005);
  player.hp.current=Math.max(0,player.hp.current-dmg);
  appendStatusLog(`Gift verursacht ${dmg} Schaden.`);
}
function applyBleedingTick(){
  const effect=player.statusEffects.find(e=>e.id==="bleeding");
  if(!effect)return;
  const dmg=4;
  player.hp.current=Math.max(0,player.hp.current-dmg);
  appendStatusLog(`Blutung verursacht ${dmg} Schaden.`);
}
function applyFireEffect(){
  const effect=player.statusEffects.find(e=>e.id==="fire");
  if(!effect)return;
  const dmg=Math.floor(player.hp.max*0.25);
  player.hp.current=Math.max(0,player.hp.current-dmg);
  appendStatusLog(`Feuer verursacht ${dmg} Schaden.`);
  addStatusEffect({id:"bleeding",name:"Blutung",type:"damage_fixed",value:4,desc:"Verliert 4 Leben pro Aktion."});
  player.traits=player.traits||[];
  player.traits=player.traits.filter(t=>t!=="Brandnarben");
  player.traits.push("Brandnarben");
  appendStatusLog("Brandnarben hinzugefügt.");
}
function applyBlessing(type){
  switch(type){
    case "divine":
      addStatusEffect({id:"bless_divine",name:"Göttlicher Segen",type:"buff",desc:"+2 auf alle Proben."});
      break;
    case "holy":
      addStatusEffect({id:"bless_holy",name:"Geweihter Segen",type:"buff",desc:"Immun gegen Flüche & dämonische Effekte."});
      break;
    case "buff":
      addStatusEffect({id:"bless_buff",name:"Segen",type:"buff",desc:"Gewährt einen kleinen Bonus (Attribut/HP/Ausdauer)."});
      break;
  }
}
function applyCurse(){
  addStatusEffect({id:"curse",name:"Fluch",type:"debuff",desc:"-2 auf alle Proben, -25% HP, -25% Ausdauer, -25% Magieresistenz."});
  player.hp.max=Math.floor(player.hp.max*0.75);
  player.stamina.max=Math.floor(player.stamina.max*0.75);
  player.magicRes=Math.floor(player.magicRes*0.75);
  appendStatusLog("Fluch wirkt: Werte reduziert.");
}
function applyStatusTicks(){
  applyPoisonTick();
  applyBleedingTick();
}
function renderStatusEffects(){
  const box=document.getElementById("status-effects");
  if(!box)return;
  box.innerHTML="";
  player.statusEffects.forEach(effect=>{
    const icon=document.createElement("div");
    icon.className="status-icon";
    icon.textContent=effect.name[0]||"?";
    icon.onclick=()=>openStatusPopup(effect.id);
    box.appendChild(icon);
  });
}

/* ============================================================
   Würfel-UI + einfache Kampffunktionen für Step 3
============================================================ */
function initDiceUI(){
  const box=document.getElementById("dice-box");
  if(!box)return;
  box.innerHTML=`
    <button class="dice-btn" onclick="rollW6()">🎲 W6</button>
    <button class="dice-btn" onclick="rollW12()">🎲 W12</button>
    <button class="dice-btn" onclick="rollW20()">🎲 W20</button>
    <button class="dice-btn" onclick="rollW100()">🎲 W100</button>
  `;
}
function setLastRoll(type,val){
  const box=document.getElementById("last-roll");
  if(box) box.textContent=`${type} → ${val}`;
  const h=document.getElementById("history-box");
  if(h){
    const div=document.createElement("div");
    div.className="history-entry";
    div.textContent=`${type} → ${val}`;
    h.prepend(div);
  }
}
function rollW6(){ const r=rollDice(6); setLastRoll("W6",r); return r; }
function rollW12(){ const r=rollDice(12); setLastRoll("W12",r); return r; }
function rollW20(){ const r=rollDice(20); setLastRoll("W20",r); return r; }
function rollW100(){ const r=rollDice(100); setLastRoll("W100",r); return r; }

/* ============================================================
   Initialisierung
============================================================ */
function initUndraEngineSteps(){
  initStep1UI();
  initStep2UI();
  updateDayDisplay();
  renderTimeline();
  initDiceUI();
  updateMoneyUI();
  updateSPUI();
}
document.addEventListener("DOMContentLoaded",()=>{
  initUndraEngineSteps();
  updateArmorBufferUI();
  renderStatusEffects();
  renderBuffs();
});


/* ============================================================
   UNDRA ENGINE v1.1 — CORE (SCHRITT 1)
   Gemeinsames Datenmodell + SP/Geld/Vital/Log-Helper
   Kompatibel mit Modulen 6–18
============================================================ */

/* -----------------------------
   ZENTRALES SPIELER-MODELL
----------------------------- */

const player = {
    // Identität
    name: "",
    raceId: "",
    professionId: "",

    // Attribute / Talente (für Proben-System)
    attributes: {},   // z.B. KK, GE, IN ...
    talents: {},

    // Vitalwerte (einheitlich)
    vital: {
        life: 10,
        maxLife: 10,
        stamina: 10,
        maxStamina: 10
    },

    // Ressourcen
    resources: {
        SP: 0,
        AE: 0,        // Astralenergie / Magie
        SG: 0,        // ggf. göttliche Punkte
        gold: 0,
        silver: 0,
        copper: 0,
        totalCopper: 0
    },

    // Kampfwerte (Basis; Module können erweitern)
    combat: {
        attack: 0,
        defense: 0,
        hitChance: 50,
        evasion: 0,
        armor: 0
    },

    // Rüstungspuffer (Modul 6)
    armorBuffer: 0,

    // Inventar / Ausrüstung (Modul 11 füllt das aus)
    inventory: {
        small: [],
        medium: [],
        large: []
    },
    equipment: {
        weapon: null,
        offhand: null,
        armor: null,
        accessory1: null,
        accessory2: null
    },

    // Fähigkeiten / Buffs / Status
    abilities: [],       // Modul 8 & 16 nutzen eigene Strukturen und erweitern
    buffs: [],
    statusEffects: [],   // Modul 18

    // Meta
    questCodes: [],      // Modul 14
    moneyHistory: [],    // Modul 10
    traits: [],          // Modul 18 (Brandnarben etc.)
    magicRes: 0,
    day: 1
};

/* -----------------------------
   KOMPAT-LAYER für hp / stamina
   (Modul 17 & 18)
----------------------------- */

// player.hp.current / player.hp.max
Object.defineProperty(player, "hp", {
    get() {
        return {
            get current() { return player.vital.life; },
            set current(v) { player.vital.life = Math.max(0, v); },
            get max() { return player.vital.maxLife; },
            set max(v) { player.vital.maxLife = v; }
        };
    }
});

// player.stamina.current / player.stamina.max
Object.defineProperty(player, "stamina", {
    get() {
        return {
            get current() { return player.vital.stamina; },
            set current(v) { player.vital.stamina = Math.max(0, v); },
            get max() { return player.vital.maxStamina; },
            set max(v) { player.vital.maxStamina = v; }
        };
    }
});

/* ============================================================
   SP-SYSTEM
============================================================ */

function grantSP(amount, reason = "Unbekannt") {
    player.resources.SP = (player.resources.SP || 0) + amount;

    // Untergrenze (optional)
    if (player.resources.SP < 0) player.resources.SP = 0;

    updateSPUI();

    // Historie-Eintrag (optional)
    const box = document.getElementById("history-box");
    if (box) {
        const line = document.createElement("div");
        line.className = "history-entry";
        line.textContent = `SP ${amount >= 0 ? "+" : ""}${amount} (${reason})`;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
    }
}

/* ============================================================
   VITALWERT-ANZEIGE
============================================================ */

function updateVitalUI() {
    // Generische Anzeige (kannst du später an deine IDs anpassen)
    const lifeCur = document.getElementById("life-current");
    const lifeMax = document.getElementById("life-max");
    const stamCur = document.getElementById("stamina-current");
    const stamMax = document.getElementById("stamina-max");

    if (lifeCur) lifeCur.textContent = player.vital.life;
    if (lifeMax) lifeMax.textContent = player.vital.maxLife;
    if (stamCur) stamCur.textContent = player.vital.stamina;
    if (stamMax) stamMax.textContent = player.vital.maxStamina;

    // Falls du auf STEP 3 andere Felder nutzt (z.B. LE/EN), kannst du hier ergänzen.
}

/* ============================================================
   SP-ANZEIGE
============================================================ */

function updateSPUI() {
    const spDisplay = document.getElementById("sp-display");
    if (spDisplay) spDisplay.textContent = player.resources.SP;

    const spAbilities = document.getElementById("abilities-sp-available");
    if (spAbilities) spAbilities.textContent = player.resources.SP;
}

/* ============================================================
   GELD-SYSTEM WRAPPER
   (Kompat für Module 15 & 17)
============================================================ */

/**
 * Wrapper, damit Module 15 & 17 mit subtractMoney() arbeiten können,
 * intern aber das Währungssystem von Modul 10 (spendMoney) genutzt wird.
 */
function subtractMoney(g = 0, s = 0, c = 0, reason = "Unbekannt") {
    if (typeof spendMoney === "function") {
        return spendMoney(g, s, c, reason); // Modul 10
    } else {
        // Fallback, falls Modul 10 noch nicht geladen ist
        const total = (g * 10000) + (s * 100) + c;
        const current =
            (player.resources.gold * 10000) +
            (player.resources.silver * 100) +
            (player.resources.copper);
        if (current < total) {
            alert("Nicht genug Geld!");
            return false;
        }
        const newTotal = current - total;
        player.resources.gold = Math.floor(newTotal / 10000);
        let rest = newTotal % 10000;
        player.resources.silver = Math.floor(rest / 100);
        player.resources.copper = rest % 100;

        updateMoneyUI(); // wird durch Modul 10 überschrieben
        grantSP(1, reason || "Geldausgabe");
        return true;
    }
}

/**
 * Dummy / Fallback – wird von Modul 10 mit einer „echten“
 * Implementierung überschrieben.
 */
function updateMoneyUI() {
    const g = document.getElementById("money-gold");
    const s = document.getElementById("money-silver");
    const c = document.getElementById("money-copper");
    if (g) g.textContent = player.resources.gold || 0;
    if (s) s.textContent = player.resources.silver || 0;
    if (c) c.textContent = player.resources.copper || 0;
}

// Kompat-Funktion für ältere Stellen, die updateGoldUI aufrufen
function updateGoldUI() {
    updateMoneyUI();
}

/* ============================================================
   GENERISCHE PLAYER-UI
============================================================ */

function updatePlayerUI() {
    updateVitalUI();
    updateSPUI();
    updateMoneyUI();

    // Armor-Buffer (Modul 6) – nur aktualisieren, wenn UI existiert
    if (typeof updateArmorBufferUI === "function") {
        updateArmorBufferUI();
    }
}

/* ============================================================
   LOG-SYSTEME (KAMPF / REISE / STATUS / QUEST / HÄNDLER / REST)
============================================================ */

function appendCombatLog(text) {
    const log = document.getElementById("combat-log");
    if (log) {
        const entry = document.createElement("div");
        entry.textContent = text;
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
    } else {
        // Fallback: Historie
        const box = document.getElementById("history-box");
        if (box) {
            const entry = document.createElement("div");
            entry.textContent = text;
            box.appendChild(entry);
            box.scrollTop = box.scrollHeight;
        }
    }
}

function appendTravelLog(text) {
    const box = document.getElementById("travel-log");
    if (box) {
        const line = document.createElement("div");
        line.textContent = text;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
    }
}

function appendStatusLog(text) {
    const box = document.getElementById("status-log");
    if (box) {
        const line = document.createElement("div");
        line.textContent = text;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
    }
}

function appendQuestLog(text) {
    const box = document.getElementById("quest-log");
    if (box) {
        const line = document.createElement("div");
        line.textContent = text;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
    }
}

function appendMerchantLog(text) {
    const box = document.getElementById("merchant-log");
    if (box) {
        const line = document.createElement("div");
        line.textContent = text;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
    }
}

function appendRestLog(text) {
    const box = document.getElementById("rest-log");
    if (box) {
        const line = document.createElement("div");
        line.textContent = text;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
    }
}

/* ============================================================
   RENDER-HOOKS FÜR MODUL 17 (RUHE)
============================================================ */

function renderStats() {
    updateVitalUI();
}

function renderMoney() {
    updateMoneyUI();
}

function renderBuffs() {
    const box = document.getElementById("buff-list");
    if (!box) return;
    box.innerHTML = "";
    (player.buffs || []).forEach(buff => {
        const line = document.createElement("div");
        line.textContent = `${buff.name} (${buff.duration} Tag)`;
        box.appendChild(line);
    });
}

// renderAll() wird in Modul 17 definiert/erweitert; falls es früher
// aufgerufen wird, gibt es keinen Crash:
if (typeof renderAll !== "function") {
    function renderAll() {
        renderStats();
        renderMoney();
        renderBuffs();
    }
}

/* ============================================================
   UNDRA ENGINE v1.1 — MODULE 1–5
   STEP 1–3, Attribute, Rasse/Profession, Vor-/Nachteile,
   Vitalwerte, Aktive Attribute, Timeline/Historie-Hooks
============================================================ */

/* -----------------------------
   STEP-NAVIGATION
----------------------------- */

let currentStep = 1;

function toStep(step) {
    currentStep = step;
    for (let i = 1; i <= 3; i++) {
        const stepEl = document.getElementById("step-" + i);
        const navEl = document.getElementById("nav-step-" + i);
        if (stepEl) stepEl.classList.toggle("active", i === step);
        if (navEl) navEl.classList.toggle("active", i === step);
    }

    if (step === 3) {
        finalizeCharacterForStep3();
    }
}

/* ============================================================
   MODUL 1 — BASISDATEN, RASSE, PROFESSION, ATTRIBUTE, RADAR
============================================================ */

/* -----------------------------
   RASSEN & PROFESSIONEN
   (für Step 1 und Modul 16)
----------------------------- */

const RACE_DEFS = {
    "Mensch (Mittelländer)": {
        raceId: "human_mittellaender",
        special: "Anpassungsfähig: +1 auf einen beliebigen Wert."
    },
    "Mensch (Thorwaler)": {
        raceId: "human_thorwaler",
        special: "Seefahrer & Kampfesmut."
    },
    "Elf (Waldelf)": {
        raceId: "elf_waldelf",
        special: "Starke Bindung zur Natur."
    },
    "Zwerg (Gebirgszwerg)": {
        raceId: "dwarf_gebirge",
        special: "Robust und widerstandsfähig."
    }
};

const PROF_DEFS = {
    "Krieger": {
        professionId: "warrior",
        bonus: { KK: 2, VE: 1 }
    },
    "Magier": {
        professionId: "mage",
        bonus: { IN: 2, KB: 1 }
    },
    "Schurke": {
        professionId: "rogue",
        bonus: { GE: 2, KK: 1 }
    },
    "Seefahrer": {
        professionId: "sailor",
        bonus: { GE: 1, IN: 1 }
    }
};

const BASE_ATTRIBUTES = [
    "KK", // Körperkraft
    "GE", // Gewandtheit
    "IN", // Intelligenz / Verstand
    "KB", // Körperbeherrschung
    "VE"  // Verteidigung / Zähigkeit
];

function initStep1UI() {
    initRaceSelectUI();
    initProfessionSelectUI();
    initAttributeUI();
    initPortraitHandler();
}

function initRaceSelectUI() {
    const sel = document.getElementById("race-select");
    if (!sel) return;
    sel.innerHTML = "";
    Object.keys(RACE_DEFS).forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
    });
    sel.addEventListener("change", onRaceChangeStep1);
    onRaceChangeStep1();
}

function onRaceChangeStep1() {
    const sel = document.getElementById("race-select");
    if (!sel) return;
    const chosen = RACE_DEFS[sel.value];
    if (!chosen) return;
    player.raceId = chosen.raceId;
    updateSpecialAbilityText(chosen.special);
}

function initProfessionSelectUI() {
    const sel = document.getElementById("profession-select");
    if (!sel) return;
    sel.innerHTML = "";
    Object.keys(PROF_DEFS).forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
    });
    sel.addEventListener("change", onProfessionChangeStep1);
    onProfessionChangeStep1();
}

function onProfessionChangeStep1() {
    const sel = document.getElementById("profession-select");
    if (!sel) return;
    const chosen = PROF_DEFS[sel.value];
    if (!chosen) return;
    player.professionId = chosen.professionId;
    applyProfessionBonuses();
    updateFinalStatsFromAttributes();
}

function updateSpecialAbilityText(text) {
    const box = document.getElementById("special-content");
    if (box) box.textContent = text || "";
}

function openSpecialModal() {
    const modal = document.getElementById("special-modal");
    if (modal) modal.style.display = "flex";
}

function closeSpecialModal() {
    const modal = document.getElementById("special-modal");
    if (modal) modal.style.display = "none";
}

/* -----------------------------
   ATTRIBUT-UI + ZUFALL
----------------------------- */

function initAttributeUI() {
    const grid = document.getElementById("attr-grid");
    if (!grid) return;
    grid.innerHTML = "";
    BASE_ATTRIBUTES.forEach(attr => {
        if (typeof player.attributes[attr] === "undefined") {
            player.attributes[attr] = 10;
        }
        const row = document.createElement("div");
        row.className = "attr-row";
        row.innerHTML = `
            <span>${attr}</span>
            <div class="val-box" id="attr-${attr}">${player.attributes[attr]}</div>
        `;
        grid.appendChild(row);
    });
    drawStep1Radar();
}

function randomizeAttributes() {
    BASE_ATTRIBUTES.forEach(attr => {
        // klassisch: 3W6
        const val = rollDice(6) + rollDice(6) + rollDice(6);
        player.attributes[attr] = val;
        const el = document.getElementById("attr-" + attr);
        if (el) el.textContent = val;
    });
    applyProfessionBonuses();
    updateFinalStatsFromAttributes();
    drawStep1Radar();
    grantSP(1, "Attribute neu gewürfelt");
}

/* kleine generische W6 Funktion; Würfelsystem (W6/W12/W20/W100)
   kommt später in separatem Modul */
function rollDice(sides) {
    return Math.floor(Math.random() * sides) + 1;
}

/* -----------------------------
   PORTRAIT-LOGIK
----------------------------- */

function initPortraitHandler() {
    const input = document.getElementById("portrait-input");
    if (!input) return;
    input.addEventListener("change", handlePortraitUpload);
}

function handlePortraitUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (ev) {
        const img = document.getElementById("preview");
        const final = document.getElementById("final-portrait");
        if (img) img.src = ev.target.result;
        if (final) final.src = ev.target.result;
    };
    reader.readAsDataURL(file);
}

/* -----------------------------
   STEP-1 RADAR (simple Spider)
----------------------------- */

function drawStep1Radar() {
    const canvas = document.getElementById("attrRadar");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const radius = Math.min(w, h) / 2 - 20;

    ctx.clearRect(0, 0, w, h);
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1;

    const maxVal = 20; // Normierung
    const count = BASE_ATTRIBUTES.length;

    // Netz
    for (let r = 0.25; r <= 1.0; r += 0.25) {
        ctx.beginPath();
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count - Math.PI / 2;
            const x = cx + Math.cos(angle) * radius * r;
            const y = cy + Math.sin(angle) * radius * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
    }

    // Werte
    ctx.beginPath();
    ctx.strokeStyle = "#d4af37";
    ctx.fillStyle = "rgba(212,175,55,0.3)";
    BASE_ATTRIBUTES.forEach((attr, i) => {
        const val = player.attributes[attr] || 0;
        const norm = Math.min(val / maxVal, 1);
        const angle = (Math.PI * 2 * i) / count - Math.PI / 2;
        const x = cx + Math.cos(angle) * radius * norm;
        const y = cy + Math.sin(angle) * radius * norm;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.closePath();
    ctx.stroke();
    ctx.fill();
}

/* ============================================================
   MODUL 2/3 — VOR-/NACHTEILE + CHRONIK + 2. RADAR
============================================================ */

const VORTEILE = [
    "Mutig",
    "Beliebt",
    "Gebildet",
    "Zäh",
    "Glückskind"
];

const NACHTEILE = [
    "Verflucht",
    "Schwach",
    "Geächtet",
    "Traumatisiert",
    "Sucht"
];

let chosenVorteile = new Set();
let chosenNachteile = new Set();

function initStep2UI() {
    initVorteileUI();
    initNachteileUI();
    updateVorNachStatus();
    drawChronikRadar();
}

function initVorteileUI() {
    const box = document.getElementById("vorteile-list");
    if (!box) return;
    box.innerHTML = "";
    VORTEILE.forEach(name => {
        const div = document.createElement("div");
        div.className = "tag";
        div.textContent = name;
        div.onclick = () => toggleVorteil(name, div);
        box.appendChild(div);
    });
}

function initNachteileUI() {
    const box = document.getElementById("nachteile-list");
    if (!box) return;
    box.innerHTML = "";
    NACHTEILE.forEach(name => {
        const div = document.createElement("div");
        div.className = "tag";
        div.textContent = name;
        div.onclick = () => toggleNachteil(name, div);
        box.appendChild(div);
    });
}

function toggleVorteil(name, el) {
    if (chosenVorteile.has(name)) {
        chosenVorteile.delete(name);
        el.classList.remove("selected");
    } else {
        chosenVorteile.add(name);
        el.classList.add("selected");
    }
    updateVorNachStatus();
}

function toggleNachteil(name, el) {
    if (chosenNachteile.has(name)) {
        chosenNachteile.delete(name);
        el.classList.remove("selected");
    } else {
        chosenNachteile.add(name);
        el.classList.add("selected");
    }
    updateVorNachStatus();
}

function updateVorNachStatus() {
    const status = document.getElementById("vn-status");
    const btn = document.getElementById("finish-step-2-btn");
    const vCount = chosenVorteile.size;
    const nCount = chosenNachteile.size;

    const valid = vCount >= 2 && nCount >= 3 && nCount >= vCount + 1;

    if (status) {
        status.textContent =
            `Vorteile: ${vCount} / min. 2, ` +
            `Nachteile: ${nCount} / min. 3, ` +
            `Nachteile ≥ Vorteile + 1: ${nCount >= vCount + 1 ? "OK" : "NEIN"}`;
    }
    if (btn) btn.disabled = !valid;
}

/* Chronik-Radar als „emotionaler Abdruck“ – hier als Dummy:
   Wir nehmen Anzahl der Vor-/Nachteile + Textlänge der Chronik */
function drawChronikRadar() {
    const canvas = document.getElementById("chronikRadar");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;
    const cx = w / 2, cy = h / 2;
    const radius = Math.min(w, h) / 2 - 20;

    ctx.clearRect(0, 0, w, h);

    const chronikText = (document.getElementById("chronik-text")?.value || "").trim();
    const originText = (document.getElementById("origin-text")?.value || "").trim();

    const vals = [
        chosenVorteile.size,
        chosenNachteile.size,
        originText.length / 100,
        chronikText.length / 100
    ];
    const maxVal = 10;
    const count = vals.length;

    ctx.strokeStyle = "#444";
    for (let r = 0.25; r <= 1.0; r += 0.25) {
        ctx.beginPath();
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count - Math.PI / 2;
            const x = cx + Math.cos(angle) * radius * r;
            const y = cy + Math.sin(angle) * radius * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
    }

    ctx.beginPath();
    ctx.strokeStyle = "#9b59b6";
    ctx.fillStyle = "rgba(155,89,182,0.3)";
    vals.forEach((v, i) => {
        const norm = Math.min(v / maxVal, 1);
        const angle = (Math.PI * 2 * i) / count - Math.PI / 2;
        const x = cx + Math.cos(angle) * radius * norm;
        const y = cy + Math.sin(angle) * radius * norm;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.closePath();
    ctx.stroke();
    ctx.fill();
}

/* ============================================================
   MODUL 4/5 — VITALWERTE, AKTIVE ATTRIBUTE, FINAL-RADAR,
   TAGESPUNKTE, TIMELINE-HOOK
============================================================ */

/* -----------------------------
   VITALWERTE AUS ATTRIBUTEN
----------------------------- */

function updateFinalStatsFromAttributes() {
    // Beispielhafte Herleitung; du kannst die Formeln anpassen
    const KK = player.attributes.KK || 0;
    const GE = player.attributes.GE || 0;
    const IN = player.attributes.IN || 0;
    const KB = player.attributes.KB || 0;
    const VE = player.attributes.VE || 0;

    player.vital.maxLife = 20 + KK + VE;
    player.vital.life = player.vital.maxLife;
    player.vital.maxStamina = 10 + GE + KB;
    player.vital.stamina = player.vital.maxStamina;

    player.combat.attack = Math.floor(KK / 2) + 5;
    player.combat.defense = Math.floor(VE / 2) + 5;
    player.combat.hitChance = 50 + Math.floor((GE + IN) / 4);
    player.combat.evasion = Math.floor(GE / 2);

    updateVitalUI();
    updateCombatDerivedUI();
    drawFinalRadar();
}

function updateCombatDerivedUI() {
    const le = document.getElementById("calc-le-val");
    const en = document.getElementById("calc-en-val");
    const rs = document.getElementById("calc-rs-val");
    const gg = document.getElementById("calc-gg-val");
    const tc = document.getElementById("calc-tc-val");

    if (le) le.textContent = player.vital.maxLife;
    if (en) en.textContent = player.vital.maxStamina;
    if (rs) rs.textContent = player.combat.defense;
    if (gg) gg.textContent = player.combat.evasion;
    if (tc) tc.textContent = player.combat.hitChance;
}

/* -----------------------------
   FINAL-RADAR (Step 3)
----------------------------- */

function drawFinalRadar() {
    const canvas = document.getElementById("finalRadar");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;
    const cx = w / 2, cy = h / 2;
    const radius = Math.min(w, h) / 2 - 20;

    ctx.clearRect(0, 0, w, h);

    const vals = [
        player.vital.maxLife,
        player.vital.maxStamina,
        player.combat.attack,
        player.combat.defense,
        player.combat.hitChance
    ];
    const maxVal = Math.max(...vals, 10);
    const count = vals.length;

    ctx.strokeStyle = "#333";
    for (let r = 0.25; r <= 1.0; r += 0.25) {
        ctx.beginPath();
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count - Math.PI / 2;
            const x = cx + Math.cos(angle) * radius * r;
            const y = cy + Math.sin(angle) * radius * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
    }

    ctx.beginPath();
    ctx.strokeStyle = "#27ae60";
    ctx.fillStyle = "rgba(39,174,96,0.3)";
    vals.forEach((v, i) => {
        const norm = Math.min(v / maxVal, 1);
        const angle = (Math.PI * 2 * i) / count - Math.PI / 2;
        const x = cx + Math.cos(angle) * radius * norm;
        const y = cy + Math.sin(angle) * radius * norm;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.closePath();
    ctx.stroke();
    ctx.fill();
}

/* -----------------------------
   AKTIVE ATTRIBUTE & TAGESPUNKTE
----------------------------- */

let dailyPoints = 0;

function initActiveAttributesUI() {
    const grid = document.getElementById("active-attr-grid");
    if (!grid) return;

    const ACTIVE = ["KK", "GE", "IN", "KB", "VE"];
    grid.innerHTML = "";

    ACTIVE.forEach(attr => {
        const row = document.createElement("div");
        row.className = "attr-row";
        row.innerHTML = `
            <span>${attr}</span>
            <div class="val-box" id="active-${attr}">
                ${player.attributes[attr] || 0}
            </div>
            <button class="btn-upgrade" onclick="upgradeActiveAttribute('${attr}')">+</button>
        `;
        grid.appendChild(row);
    });

    updateDailyPointsUI();
}

function upgradeActiveAttribute(attr) {
    if (dailyPoints <= 0) {
        alert("Keine Tagespunkte mehr!");
        return;
    }
    player.attributes[attr] = (player.attributes[attr] || 0) + 1;
    dailyPoints -= 1;
    const el = document.getElementById("active-" + attr);
    if (el) el.textContent = player.attributes[attr];
    updateDailyPointsUI();
    updateFinalStatsFromAttributes();
    drawFinalRadar();
    grantSP(1, "Aktives Attribut gesteigert");
}

function updateDailyPointsUI() {
    const el = document.getElementById("daily-points-display");
    if (el) el.textContent = dailyPoints;
}

/* -----------------------------
   TIMELINE & TAGESSYSTEM (HOOK)
----------------------------- */

let timeline = [];

function endDay() {
    // Tageseintrag
    timeline.push({
        day: player.day,
        timestamp: Date.now()
    });
    renderTimeline();

    // Tagespunkte für den nächsten Tag
    player.day += 1;
    dailyPoints = 1; // z.B. 1 aktiver Attributpunkt pro Tag
    updateDailyPointsUI();
    updateDayDisplay();

    // Hooks für Rest-System, Buffs, etc.
    if (typeof reduceBuffDurations === "function") {
        reduceBuffDurations();
        renderBuffs();
    }

    // kleines Dankes-/Feedback-Popup
    openThanksModal();
}

function renderTimeline() {
    const box = document.getElementById("timeline-box");
    if (!box) return;
    box.innerHTML = "";
    timeline.forEach(entry => {
        const div = document.createElement("div");
        div.className = "timeline-entry";
        const date = new Date(entry.timestamp);
        div.textContent = `Tag ${entry.day} beendet (${date.toLocaleString()})`;
        box.appendChild(div);
    });
}

function updateDayDisplay() {
    const el = document.getElementById("day-display");
    if (el) el.textContent = player.day;
}

function openThanksModal() {
    const modal = document.getElementById("thanks-modal");
    const text = document.getElementById("thanks-text");
    if (text) {
        text.textContent = `Tag ${player.day - 1} ist beendet. Ein neuer Tag beginnt.`;
    }
    if (modal) modal.style.display = "flex";
}

function closeThanks() {
    const modal = document.getElementById("thanks-modal");
    if (modal) modal.style.display = "none";
}

/* ============================================================
   STEP-3 FINALISIERUNG
============================================================ */

function finalizeCharacterForStep3() {
    // Name
    const nameInput = document.getElementById("char-name");
    if (nameInput) {
        player.name = nameInput.value.trim();
    }

    // Vitalwerte/Combat aus Attributen frisch berechnen
    updateFinalStatsFromAttributes();

    // Aktive Attribute UI initiieren
    initActiveAttributesUI();

    // Tagespunkte für den Start
    if (player.day === 1 && dailyPoints === 0) {
        dailyPoints = 1;
        updateDailyPointsUI();
    }

    // Portrait von Step 1 nach Final übernehmen
    const src = document.getElementById("preview")?.src;
    const finalImg = document.getElementById("final-portrait");
    if (finalImg && src) finalImg.src = src;

    // Würfel-UI wird in Modul „Würfel/Kampf“ initialisiert (später).
}

/* ============================================================
   INITIALISIERUNG ALLER STEPS
============================================================ */

function initUndraEngineSteps() {
    initStep1UI();
    initStep2UI();
    updateDayDisplay();
    renderTimeline();
}

// call this after DOMContentLoaded and nachdem Core geladen ist:
document.addEventListener("DOMContentLoaded", () => {
    initUndraEngineSteps();
});

/* ============================================================
   MODUL 6 — TREFFERZONEN + RÜSTUNGSPUFFER + REPARATUR (v1.1)
============================================================ */

/* 1. ZONEN-STUFEN */

const ZONE_STATES = [
    "Perfekt",
    "Gut",
    "Leicht beschädigt",
    "Beschädigt",
    "Schwer beschädigt"
];

/* 2. ZONEN-DATEN */

const hitzones = {
    head: {
        name: "Kopf",
        stateIndex: 1,
        repairCost: { gold: 5, sp: 1 }
    },
    neck: {
        name: "Hals",
        stateIndex: 0,
        repairCost: { gold: 3, sp: 1 }
    },
    torso: {
        name: "Oberkörper",
        stateIndex: 0,
        repairCost: { gold: 4, sp: 1 }
    },
    legs: {
        name: "Unterkörper",
        stateIndex: 2,
        repairCost: { gold: 4, sp: 1 }
    },
    limbs: {
        name: "Gliedmaßen",
        stateIndex: 3,
        repairCost: { gold: 6, sp: 2 }
    }
};

/* 3. RÜSTUNGSPUFFER DES SPIELERS */

player.armorBuffer = player.armorBuffer || 0;

function updateArmorBufferUI() {
    const el = document.getElementById("armor-buffer");
    if (el) el.textContent = player.armorBuffer;
}

/* 4. UPGRADE: RÜSTUNGSPUFFER */

function upgradeArmorBuffer() {
    const cost = 1000;
    if (player.resources.SP < cost) {
        alert("Nicht genug SP für Rüstungspuffer!");
        return;
    }
    player.resources.SP -= cost;
    player.armorBuffer += 1;

    grantSP(1, "Upgrade: Rüstungspuffer");
    updateSPUI();
    updateArmorBufferUI();
}

/* 5. ZONEN-VERSCHLECHTERUNG / VERBESSERUNG */

function worsenZone(zoneKey) {
    const zone = hitzones[zoneKey];
    if (!zone) return;
    if (zone.stateIndex < ZONE_STATES.length - 1) {
        zone.stateIndex++;
    }
}

function improveZone(zoneKey) {
    const zone = hitzones[zoneKey];
    if (!zone) return;
    if (zone.stateIndex > 0) {
        zone.stateIndex--;
    }
}

/* 6. TREFFERLOGIK MIT RÜSTUNGSPUFFER */

function applyHitToPlayer(damage, zoneKey) {
    const zone = hitzones[zoneKey] || hitzones.torso;

    // 1. Rüstungspuffer
    if (player.armorBuffer > 0) {
        player.armorBuffer -= 1;
        updateArmorBufferUI();
        appendCombatLog(`Rüstungspuffer absorbiert den Treffer!`);
        return;
    }

    // 2. Zone verschlechtert sich
    worsenZone(zoneKey);
    updateZoneUI(zoneKey);

    // 3. Schaden
    const oldLife = player.vital.life;
    player.vital.life = Math.max(0, player.vital.life - (damage || 0));

    // 4. SP für Lebensverlust
    const loss = oldLife - player.vital.life;
    if (loss > 0) {
        grantSP(loss * 2, "Lebensverlust");
    }

    updateVitalUI();
}

/* 7. REPARATUR MIT GOLD */

function repairZoneWithGold(zoneKey) {
    const zone = hitzones[zoneKey];
    if (!zone) return;
    const cost = zone.repairCost.gold;

    if (!hasMoney(cost, 0, 0)) {
        alert("Nicht genug Gold!");
        return;
    }

    // nutzt Währungssystem (Modul 10) via spendMoney/subtractMoney
    if (!subtractMoney(cost, 0, 0, "Reparatur (Gold)")) return;

    improveZone(zoneKey);
    grantSP(1, "Reparatur (Gold)");
    updateZoneUI(zoneKey);
    closeRepairPopup();
}

/* 8. REPARATUR MIT SP */

function repairZoneWithSP(zoneKey) {
    const zone = hitzones[zoneKey];
    if (!zone) return;
    const cost = zone.repairCost.sp;

    if (player.resources.SP < cost) {
        alert("Nicht genug SP!");
        return;
    }

    player.resources.SP -= cost;
    improveZone(zoneKey);

    grantSP(1, "Reparatur (SP)");
    updateSPUI();
    updateZoneUI(zoneKey);
    closeRepairPopup();
}

/* 9. POPUP-LOGIK */

let currentRepairZone = null;

function openRepairPopup(zoneKey) {
    currentRepairZone = zoneKey;
    const zone = hitzones[zoneKey];
    if (!zone) return;

    const text = document.getElementById("popup-armor-text");
    const btnG = document.getElementById("btn-repair-gold");
    const btnS = document.getElementById("btn-repair-sp");
    const popup = document.getElementById("popup-armor-repair");

    if (text) {
        text.textContent = `${zone.name} – Zustand: ${ZONE_STATES[zone.stateIndex]}`;
    }
    if (btnG) btnG.textContent = `Mit ${zone.repairCost.gold} Gold reparieren`;
    if (btnS) btnS.textContent = `Mit ${zone.repairCost.sp} SP reparieren`;
    if (popup) popup.classList.remove("hidden");
}

function closeRepairPopup() {
    const popup = document.getElementById("popup-armor-repair");
    if (popup) popup.classList.add("hidden");
    currentRepairZone = null;
}

/* 10. POPUP BUTTON EVENTS – nur binden, wenn DOM-Elemente existieren */

document.addEventListener("DOMContentLoaded", () => {
    const btnG = document.getElementById("btn-repair-gold");
    const btnS = document.getElementById("btn-repair-sp");
    const btnC = document.getElementById("btn-repair-cancel");

    if (btnG) btnG.addEventListener("click", () => {
        if (currentRepairZone) repairZoneWithGold(currentRepairZone);
    });
    if (btnS) btnS.addEventListener("click", () => {
        if (currentRepairZone) repairZoneWithSP(currentRepairZone);
    });
    if (btnC) btnC.addEventListener("click", closeRepairPopup);
});

/* 11. UI UPDATE FÜR ZONEN */

function updateZoneUI(zoneKey) {
    const zone = hitzones[zoneKey];
    if (!zone) return;
    const nameEl = document.getElementById("zone-info-name");
    const stateEl = document.getElementById("zone-info-state");
    if (nameEl) nameEl.textContent = zone.name;
    if (stateEl) stateEl.textContent = ZONE_STATES[zone.stateIndex];
}

/* ============================================================
   MODUL 7 — KAMPFENGINE (v1.1, integriert mit Mod 6 & 12)
============================================================ */

let currentEnemy = null;
let playerAction = null;
let enemyAction = null;

function startCombat(enemy) {
    // enemy aus Modul 12 kann vital/combat-Struktur haben → kompatibel machen:
    if (enemy) {
        currentEnemy = enemy;
        if (typeof currentEnemy.life === "undefined" && currentEnemy.vital) {
            currentEnemy.life = currentEnemy.vital.life;
        }
        if (typeof currentEnemy.damage === "undefined") {
            currentEnemy.damage = (currentEnemy.combat?.attack || 5);
        }
        if (typeof currentEnemy.hitChance === "undefined") {
            currentEnemy.hitChance = 50 + Math.floor((currentEnemy.combat?.attack || 0) / 2);
        }
        if (typeof currentEnemy.evasion === "undefined") {
            currentEnemy.evasion = Math.floor((currentEnemy.attributes?.GE || 10) / 2);
        }
    } else {
        currentEnemy = null;
    }

    playerAction = null;
    enemyAction = null;

    if (currentEnemy) {
        appendCombatLog(`Ein ${currentEnemy.name} greift dich an!`);
    }

    updateEnemyUI();
    updatePlayerUI();
    enableCombatUI();
}

function endCombat(result) {
    disableCombatUI();
    if (!currentEnemy) return;

    if (result === "victory") {
        appendCombatLog(`Du hast ${currentEnemy.name} besiegt!`);
        if (typeof onEnemyDefeated === "function") {
            onEnemyDefeated(currentEnemy); // Hook Modul 12 (SP + Loot)
        }
    } else {
        appendCombatLog(`Du wurdest besiegt.`);
    }

    currentEnemy = null;
}

function isCombatOver() {
    if (player.vital.life <= 0) return "defeat";
    if (currentEnemy && currentEnemy.life <= 0) return "victory";
    return false;
}

/* SPIELERAKTIONEN */

function playerAttack() {
    playerAction = "attack";
    appendCombatLog("Du greifst an!");
    executePlayerAction();
}

function playerDefend() {
    playerAction = "defend";
    appendCombatLog("Du gehst in Verteidigungshaltung.");
    executePlayerAction();
}

function playerDodge() {
    playerAction = "dodge";
    appendCombatLog("Du versuchst auszuweichen.");
    executePlayerAction();
}

/* SPIELERAKTION AUSFÜHREN */

function executePlayerAction() {
    if (!currentEnemy) return;

    if (playerAction === "attack") {
        const chance = calculateHitChance(player, currentEnemy);
        const hit = rollHit(chance);

        if (hit) {
            const dmg = calculateDamage(player);
            currentEnemy.life = Math.max(0, currentEnemy.life - dmg);
            appendCombatLog(`Du triffst und verursachst ${dmg} Schaden!`);
        } else {
            appendCombatLog("Du verfehlst dein Ziel.");
        }
    }

    updateEnemyUI();
    const result = isCombatOver();
    if (result) {
        endCombat(result);
        return;
    }

    enemyTurn();
}

/* GEGNERZUG */

function enemyTurn() {
    if (!currentEnemy) return;

    enemyAction = enemyChooseAction();

    if (enemyAction === "attack") {
        enemyAttack();
    } else {
        appendCombatLog(`${currentEnemy.name} zögert...`);
    }

    const result = isCombatOver();
    if (result) {
        endCombat(result);
        return;
    }
}

/* GEGNER-KI */

function enemyChooseAction() {
    if (playerAction === "defend") {
        return Math.random() < 0.5 ? "attack" : "wait";
    }
    if (playerAction === "dodge") {
        return Math.random() < 0.7 ? "attack" : "wait";
    }
    return "attack";
}

/* GEGNERANGRIFF */

function enemyAttack() {
    if (!currentEnemy) return;

    appendCombatLog(`${currentEnemy.name} greift an!`);

    const chance = calculateHitChance(currentEnemy, player);
    const hit = rollHit(chance);

    if (!hit) {
        appendCombatLog(`${currentEnemy.name} verfehlt dich.`);
        return;
    }

    let dmg = calculateDamage(currentEnemy);

    if (playerAction === "defend") {
        dmg = Math.floor(dmg * 0.5);
    }

    if (playerAction === "dodge") {
        if (Math.random() < 0.5) {
            appendCombatLog("Du weichst erfolgreich aus!");
            return;
        } else {
            dmg = Math.floor(dmg * 1.2);
        }
    }

    const zoneKey = getRandomZoneKey();
    applyHitToPlayer(dmg, zoneKey);
}

/* TREFFERCHANCE */

function calculateHitChance(attacker, defender) {
    const base = attacker.combat?.hitChance || attacker.hitChance || 50;
    const mod = defender.combat?.evasion || defender.evasion || 0;
    return Math.max(5, Math.min(95, base - mod));
}

function rollHit(chance) {
    return Math.random() * 100 < chance;
}

/* SCHADEN */

function calculateDamage(attacker) {
    if (attacker === player) {
        const base = player.combat.attack || 5;
        const variance = Math.floor(Math.random() * 3);
        return base + variance;
    } else {
        const base = attacker.damage || attacker.combat?.attack || 5;
        const variance = Math.floor(Math.random() * 3);
        return base + variance;
    }
}

/* ZUFÄLLIGE TREFFERZONE */

function getRandomZoneKey() {
    const keys = Object.keys(hitzones);
    return keys[Math.floor(Math.random() * keys.length)];
}

/* UI FUNKTIONEN */

function updateEnemyUI() {
    const lifeEl = document.getElementById("enemy-life");
    const nameEl = document.getElementById("enemy-name");
    if (!currentEnemy) {
        if (lifeEl) lifeEl.textContent = "-";
        if (nameEl) nameEl.textContent = "—";
        return;
    }
    if (lifeEl) lifeEl.textContent = currentEnemy.life;
    if (nameEl) nameEl.textContent = currentEnemy.name;
}

function enableCombatUI() {
    const ui = document.getElementById("combat-ui");
    if (ui) ui.classList.remove("hidden");
}

function disableCombatUI() {
    const ui = document.getElementById("combat-ui");
    if (ui) ui.classList.add("hidden");
}

/* ============================================================
   MODUL 8 — FÄHIGKEITEN-SYSTEM (KAMPF-AKTIVE)
   (unverändert, nur minimal defensiver)
============================================================ */

const abilityLibrary = {
    powerStrike: {
        id: "powerStrike",
        name: "Powerschlag",
        type: "active",
        cost: { ae: 0, sg: 0, stamina: 5, sp: 0 },
        cooldown: 3,
        currentCooldown: 0,
        description: "Starker Angriff: +50% Schaden, -20% Trefferchance.",
        effect: function (attacker, defender) {
            const baseChance = calculateHitChance(attacker, defender) - 20;
            const hit = rollHit(baseChance);
            if (!hit) return { hit: false, damage: 0 };
            let dmg = Math.floor(calculateDamage(attacker) * 1.5);
            return { hit: true, damage: dmg };
        }
    },
    precisionStrike: {
        id: "precisionStrike",
        name: "Präzisionsangriff",
        type: "active",
        cost: { ae: 0, sg: 0, stamina: 4, sp: 0 },
        cooldown: 2,
        currentCooldown: 0,
        description: "Gezielter Angriff: +20% Trefferchance.",
        effect: function (attacker, defender) {
            const baseChance = calculateHitChance(attacker, defender) + 20;
            const hit = rollHit(baseChance);
            if (!hit) return { hit: false, damage: 0 };
            let dmg = calculateDamage(attacker);
            return { hit: true, damage: dmg };
        }
    },
    shieldBlock: {
        id: "shieldBlock",
        name: "Schildblock",
        type: "active",
        cost: { ae: 0, sg: 0, stamina: 3, sp: 0 },
        cooldown: 4,
        currentCooldown: 0,
        description: "Blockt den nächsten Angriff vollständig.",
        effect: function (attacker, defender) {
            defender.tempBlock = true;
            return { hit: false, damage: 0 };
        }
    },
    dodgeRoll: {
        id: "dodgeRoll",
        name: "Ausweichrolle",
        type: "active",
        cost: { ae: 0, sg: 0, stamina: 4, sp: 0 },
        cooldown: 3,
        currentCooldown: 0,
        description: "80% Chance komplett auszuweichen.",
        effect: function (attacker, defender) {
            defender.tempDodge = true;
            return { hit: false, damage: 0 };
        }
    },
    magicBolt: {
        id: "magicBolt",
        name: "Magischer Stoß",
        type: "active",
        cost: { ae: 5, sg: 0, stamina: 0, sp: 0 },
        cooldown: 3,
        currentCooldown: 0,
        description: "Magischer Angriff ignoriert Rüstungspuffer.",
        effect: function (attacker, defender) {
            const hit = rollHit(calculateHitChance(attacker, defender));
            if (!hit) return { hit: false, damage: 0 };
            let dmg = calculateDamage(attacker) + 3;
            return { hit: true, damage: dmg, ignoreArmor: true };
        }
    },
    passiveAccuracy: {
        id: "passiveAccuracy",
        name: "Präzisionstraining",
        type: "passive",
        bonus: { hitChance: 5 },
        description: "+5% Trefferchance dauerhaft."
    },
    passiveDefense: {
        id: "passiveDefense",
        name: "Defensivhaltung",
        type: "passive",
        bonus: { defense: 10 },
        description: "+10 Verteidigung dauerhaft."
    }
};

player.abilities = player.abilities || [];

/* PASSIVE FÄHIGKEITEN AKTIVIEREN */

function applyPassiveAbilities() {
    player.tempBonuses = { hitChance: 0, defense: 0 };

    (player.abilities || []).forEach(id => {
        const ab = abilityLibrary[id];
        if (ab && ab.type === "passive") {
            if (ab.bonus.hitChance) player.tempBonuses.hitChance += ab.bonus.hitChance;
            if (ab.bonus.defense) player.tempBonuses.defense += ab.bonus.defense;
        }
    });

    // auf combat-Werte aufaddieren
    player.combat.hitChance += player.tempBonuses.hitChance;
    player.combat.defense += player.tempBonuses.defense;
}

/* FÄHIGKEIT EINSETZEN */

function useAbility(id) {
    const ab = abilityLibrary[id];
    if (!ab) return;
    if (ab.currentCooldown > 0) {
        appendCombatLog(`${ab.name} ist noch nicht bereit.`);
        return;
    }
    if (!hasAbilityResources(ab)) {
        appendCombatLog(`Nicht genug Ressourcen für ${ab.name}.`);
        return;
    }

    spendAbilityResources(ab);
    ab.currentCooldown = ab.cooldown;

    const result = ab.effect(player, currentEnemy);
    if (result.hit) {
        if (result.ignoreArmor) {
            currentEnemy.life = Math.max(0, currentEnemy.life - result.damage);
        } else {
            currentEnemy.life = Math.max(0, currentEnemy.life - result.damage);
        }
        appendCombatLog(`${ab.name} trifft für ${result.damage} Schaden!`);
    } else {
        appendCombatLog(`${ab.name} verfehlt.`);
    }

    updateEnemyUI();
    const end = isCombatOver();
    if (end) {
        endCombat(end);
        return;
    }
    enemyTurn();
}

/* RESSOURCENPRÜFUNG */

function hasAbilityResources(ab) {
    if (ab.cost.ae && player.resources.AE < ab.cost.ae) return false;
    if (ab.cost.sg && player.resources.SG < ab.cost.sg) return false;
    if (ab.cost.stamina && player.vital.stamina < ab.cost.stamina) return false;
    if (ab.cost.sp && player.resources.SP < ab.cost.sp) return false;
    return true;
}

function spendAbilityResources(ab) {
    if (ab.cost.ae) player.resources.AE -= ab.cost.ae;
    if (ab.cost.sg) player.resources.SG -= ab.cost.sg;
    if (ab.cost.stamina) player.vital.stamina -= ab.cost.stamina;
    if (ab.cost.sp) player.resources.SP -= ab.cost.sp;
    updatePlayerUI();
}

/* COOLDOWN-TICK */

function tickAbilityCooldowns() {
    (player.abilities || []).forEach(id => {
        const ab = abilityLibrary[id];
        if (ab && ab.currentCooldown > 0) {
            ab.currentCooldown -= 1;
            if (ab.currentCooldown < 0) ab.currentCooldown = 0;
        }
    });
}

/* UI-AKTUALISIERUNG */

function updateAbilityUI() {
    const container = document.getElementById("ability-list");
    if (!container) return;
    container.innerHTML = "";

    (player.abilities || []).forEach(id => {
        const ab = abilityLibrary[id];
        if (!ab) return;
        const btn = document.createElement("button");
        btn.textContent = `${ab.name} (${ab.currentCooldown})`;
        btn.disabled = ab.currentCooldown > 0;
        btn.onclick = () => useAbility(id);
        container.appendChild(btn);
    });
}

/* ============================================================
   MODUL 9 — PROBEN-SYSTEM (leicht angepasst an player.attributes)
============================================================ */

function rollD20() {
    return Math.floor(Math.random() * 20) + 1;
}

const DIFFICULTY = {
    veryEasy: 5,
    easy: 8,
    normal: 12,
    hard: 15,
    veryHard: 18,
    extreme: 20
};

function calculateProbeResult(value, modifier, difficulty) {
    const roll = rollD20();
    const total = value + modifier;
    let success = total >= difficulty;
    let critical = null;
    let spGain = 0;

    if (roll === 1) {
        critical = "success";
        success = true;
        spGain = 2;
    } else if (roll === 20) {
        critical = "fail";
        success = false;
        spGain = -1;
    } else if (success) {
        spGain = 1;
    }

    if (spGain !== 0) {
        grantSP(spGain, "Probe");
    }

    return {
        roll,
        total,
        difficulty,
        success,
        critical,
        spGain
    };
}

function performAttributeProbe(attribute, modifier = 0, difficulty = DIFFICULTY.normal) {
    const value = player.attributes[attribute] || 0;
    const result = calculateProbeResult(value, modifier, difficulty);
    showProbeResult(result);
    return result;
}

function performTalentProbe(talent, modifier = 0, difficulty = DIFFICULTY.normal) {
    const value = player.talents[talent] || 0;
    const result = calculateProbeResult(value, modifier, difficulty);
    showProbeResult(result);
    return result;
}

function performCombinedProbe(attr1, attr2, modifier = 0, difficulty = DIFFICULTY.normal) {
    const value = (player.attributes[attr1] || 0) + (player.attributes[attr2] || 0);
    const result = calculateProbeResult(value, modifier, difficulty);
    showProbeResult(result);
    return result;
}

function showProbeResult(result) {
    const box = document.getElementById("probe-result");
    if (!box) return;
    box.innerHTML = `
        <div>Wurf: ${result.roll}</div>
        <div>Gesamt: ${result.total}</div>
        <div>Schwierigkeit: ${result.difficulty}</div>
        <div>Erfolg: ${result.success ? "Ja" : "Nein"}</div>
        <div>Kritisch: ${result.critical ? result.critical : "Nein"}</div>
        <div>SP: ${result.spGain}</div>
    `;
    box.classList.remove("hidden");
}

function openProbePopup() {
    const popup = document.getElementById("probe-popup");
    if (popup) popup.classList.remove("hidden");
}

function closeProbePopup() {
    const popup = document.getElementById("probe-popup");
    if (popup) popup.classList.add("hidden");
}

/* ============================================================
   MODUL 10 — WÄHRUNGSSYSTEM (leicht mit Core verheiratet)
============================================================ */

player.resources.gold = player.resources.gold || 0;
player.resources.silver = player.resources.silver || 0;
player.resources.copper = player.resources.copper || 0;
player.resources.totalCopper = player.resources.totalCopper || 0;
player.moneyHistory = player.moneyHistory || [];

function convertToCopper(g = 0, s = 0, c = 0) {
    return (g * 10000) + (s * 100) + c;
}

function convertFromCopper(total) {
    const gold = Math.floor(total / 10000);
    total %= 10000;
    const silver = Math.floor(total / 100);
    total %= 100;
    const copper = total;
    return { gold, silver, copper };
}

function syncMoney() {
    const total = convertToCopper(
        player.resources.gold,
        player.resources.silver,
        player.resources.copper
    );
    player.resources.totalCopper = total;
    const split = convertFromCopper(total);
    player.resources.gold = split.gold;
    player.resources.silver = split.silver;
    player.resources.copper = split.copper;
    updateMoneyUI();
}

function addMoney(g = 0, s = 0, c = 0, reason = "Unbekannt") {
    const amountCopper = convertToCopper(g, s, c);
    player.resources.totalCopper += amountCopper;
    const split = convertFromCopper(player.resources.totalCopper);
    player.resources.gold = split.gold;
    player.resources.silver = split.silver;
    player.resources.copper = split.copper;

    player.moneyHistory.push({
        amount: { gold: g, silver: s, copper: c },
        reason,
        time: Date.now()
    });

    updateMoneyUI();
}

function spendMoney(g = 0, s = 0, c = 0, reason = "Unbekannt") {
    const costCopper = convertToCopper(g, s, c);
    if (player.resources.totalCopper < costCopper) {
        alert("Nicht genug Geld!");
        return false;
    }
    player.resources.totalCopper -= costCopper;
    const split = convertFromCopper(player.resources.totalCopper);
    player.resources.gold = split.gold;
    player.resources.silver = split.silver;
    player.resources.copper = split.copper;

    player.moneyHistory.push({
        amount: { gold: -g, silver: -s, copper: -c },
        reason,
        time: Date.now()
    });

    grantSP(1, "Geldausgabe");
    updateMoneyUI();
    return true;
}

function hasMoney(g = 0, s = 0, c = 0) {
    const costCopper = convertToCopper(g, s, c);
    return player.resources.totalCopper >= costCopper;
}

function updateMoneyUI() {
    const g = document.getElementById("money-gold");
    const s = document.getElementById("money-silver");
    const c = document.getElementById("money-copper");
    if (g) g.textContent = player.resources.gold;
    if (s) s.textContent = player.resources.silver;
    if (c) c.textContent = player.resources.copper;

    const currencyDisplay = document.getElementById("currency-display");
    if (currencyDisplay) {
        currencyDisplay.textContent =
            `${player.resources.gold} G ${player.resources.silver} S ${player.resources.copper} K`;
    }
}

function openMoneyHistory() {
    const box = document.getElementById("money-history");
    if (!box) return;
    box.innerHTML = "";
    player.moneyHistory.forEach(entry => {
        const div = document.createElement("div");
        div.textContent =
            `${entry.amount.gold}G ${entry.amount.silver}S ${entry.amount.copper}K — ${entry.reason}`;
        box.appendChild(div);
    });
    box.classList.remove("hidden");
}

function closeMoneyHistory() {
    const box = document.getElementById("money-history");
    if (box) box.classList.add("hidden");
}

/* ============================================================
   MODUL 11 — INVENTAR-SYSTEM (3 Spalten à 10)
============================================================ */

player.inventory = player.inventory || {
    small: Array(10).fill(null),
    medium: Array(10).fill(null),
    large: Array(10).fill(null)
};

player.equipment = player.equipment || {
    weapon: null,
    offhand: null,
    armor: null,
    accessory1: null,
    accessory2: null
};

const itemLibrary = {
    healingHerb: {
        id: "healingHerb",
        name: "Heilkraut",
        type: "consumable",
        size: "small",
        icon: "🌿",
        effect: function () {
            player.vital.life = Math.min(player.vital.maxLife, player.vital.life + 5);
            grantSP(1, "Item benutzt");
            updatePlayerUI();
        }
    },
    bread: {
        id: "bread",
        name: "Brotlaib",
        type: "consumable",
        size: "small",
        icon: "🍞",
        effect: function () {
            player.vital.stamina = Math.min(player.vital.maxStamina, player.vital.stamina + 3);
            grantSP(1, "Item benutzt");
            updatePlayerUI();
        }
    },
    swordBasic: {
        id: "swordBasic",
        name: "Einfache Klinge",
        type: "weapon",
        size: "medium",
        icon: "🗡️",
        stats: { damage: 2 }
    },
    leatherArmor: {
        id: "leatherArmor",
        name: "Lederharnisch",
        type: "armor",
        size: "large",
        icon: "🛡️",
        stats: { armor: 1 }
    }
};

function addItem(id) {
    const item = itemLibrary[id];
    if (!item) return false;
    const inv = player.inventory[item.size];
    for (let i = 0; i < inv.length; i++) {
        if (inv[i] === null) {
            inv[i] = { id: id };
            updateInventoryUI();
            return true;
        }
    }
    alert("Kein Platz im Inventar!");
    return false;
}

function removeItem(size, index) {
    player.inventory[size][index] = null;
    updateInventoryUI();
}

function useItem(size, index) {
    const entry = player.inventory[size][index];
    if (!entry) return;
    const item = itemLibrary[entry.id];
    if (!item || item.type !== "consumable") return;
    item.effect();
    removeItem(size, index);
}

function equipItem(size, index) {
    const entry = player.inventory[size][index];
    if (!entry) return;
    const item = itemLibrary[entry.id];
    if (!item) return;
    let slot = null;
    if (item.type === "weapon") slot = "weapon";
    if (item.type === "armor") slot = "armor";
    if (item.type === "offhand") slot = "offhand";
    if (!slot) return;
    if (player.equipment[slot] !== null) {
        alert("Slot ist belegt!");
        return;
    }
    player.equipment[slot] = entry.id;
    removeItem(size, index);
    grantSP(1, "Item ausgerüstet");
    updateEquipmentUI();
}

function unequipItem(slot) {
    const id = player.equipment[slot];
    if (!id) return;
    const item = itemLibrary[id];
    if (!item) return;
    if (addItem(id)) {
        player.equipment[slot] = null;
        updateEquipmentUI();
    }
}

let pendingSell = { size: null, index: null };

function openSellPopup(size, index) {
    pendingSell.size = size;
    pendingSell.index = index;
    const popup = document.getElementById("sell-popup");
    if (popup) popup.classList.remove("hidden");
}

function closeSellPopup() {
    const popup = document.getElementById("sell-popup");
    if (popup) popup.classList.add("hidden");
}

function discardItem() {
    removeItem(pendingSell.size, pendingSell.index);
    closeSellPopup();
}

function openSellValuePopup() {
    closeSellPopup();
    const popup = document.getElementById("sell-value-popup");
    if (popup) popup.classList.remove("hidden");
}

function closeSellValuePopup() {
    const popup = document.getElementById("sell-value-popup");
    if (popup) popup.classList.add("hidden");
}

function confirmSell() {
    const g = parseInt(document.getElementById("sell-gold").value) || 0;
    const s = parseInt(document.getElementById("sell-silver").value) || 0;
    const c = parseInt(document.getElementById("sell-copper").value) || 0;
    addMoney(g, s, c, "Item verkauft");
    grantSP(1, "Item verkauft");
    removeItem(pendingSell.size, pendingSell.index);
    closeSellValuePopup();
}

function updateInventoryUI() {
    ["small", "medium", "large"].forEach(size => {
        const container = document.getElementById(`inv-${size}`);
        if (!container) return;
        container.innerHTML = "";
        player.inventory[size].forEach((entry, index) => {
            const slot = document.createElement("div");
            slot.className = "inv-slot";
            if (entry) {
                const item = itemLibrary[entry.id];
                slot.innerHTML = `
                    <div class="inv-icon">${item.icon}</div>
                    <div class="inv-name">${item.name}</div>
                    <div class="inv-sell" onclick="openSellPopup('${size}', ${index})">🪙</div>
                `;
                if (item.type === "consumable") {
                    const btn = document.createElement("button");
                    btn.textContent = "Benutzen";
                    btn.onclick = () => useItem(size, index);
                    slot.appendChild(btn);
                }
                if (item.type === "weapon" || item.type === "armor") {
                    const btn = document.createElement("button");
                    btn.textContent = "Ausrüsten";
                    btn.onclick = () => equipItem(size, index);
                    slot.appendChild(btn);
                }
            }
            container.appendChild(slot);
        });
    });
}

function updateEquipmentUI() {
    Object.keys(player.equipment).forEach(slot => {
        const box = document.getElementById(`equip-${slot}`);
        const id = player.equipment[slot];
        if (!box) return;
        if (!id) {
            box.textContent = "—";
        } else {
            box.textContent = itemLibrary[id].name;
        }
    });
}

function addLoot(items) {
    items.forEach(id => addItem(id));
    updateInventoryUI();
}

/* ============================================================
   MODUL 12 — DYNAMISCHES GEGNER-SYSTEM (angepasst an Mod 7)
============================================================ */

const ENEMY_BASE = {
    KK: 10,
    GE: 10,
    IN: 10,
    KB: 10,
    VE: 10,
    life: 20,
    stamina: 10,
    attack: 10,
    defense: 10,
    armor: 0
};

const ENEMY_TYPES = {
    humanoid: {
        name: "Humanoid",
        mods: { KK: 0, GE: 0, IN: 0, KB: 1, VE: 0 },
        abilities: ["precisionStrike", "shieldBlock"],
        loot: [
            { id: "bread", chance: 40 },
            { id: "healingHerb", chance: 20 },
            { id: "swordBasic", chance: 10 }
        ]
    },
    beast: {
        name: "Tier",
        mods: { KK: 1, GE: 2, IN: -1, KB: 0, VE: 0 },
        abilities: ["powerStrike"],
        loot: [
            { id: "healingHerb", chance: 30 }
        ]
    },
    demon: {
        name: "Dämon",
        mods: { KK: 2, GE: 1, IN: 2, KB: 1, VE: 1 },
        abilities: ["magicBolt"],
        loot: [
            { id: "healingHerb", chance: 20 },
            { id: "swordBasic", chance: 5 }
        ]
    },
    undead: {
        name: "Untot",
        mods: { KK: 1, GE: -1, IN: 0, KB: 2, VE: 2 },
        abilities: ["powerStrike"],
        loot: [
            { id: "healingHerb", chance: 10 }
        ]
    }
};

function scaleEnemyStats(base, mods, level) {
    return {
        KK: base.KK + mods.KK + level,
        GE: base.GE + mods.GE + level,
        IN: base.IN + mods.IN + level,
        KB: base.KB + mods.KB + level,
        VE: base.VE + mods.VE + level,
        life: base.life + level * 5,
        stamina: base.stamina + level * 2,
        attack: base.attack + level,
        defense: base.defense + level,
        armor: base.armor + Math.floor(level / 5)
    };
}

function generateEnemy(level, typeKey) {
    const type = ENEMY_TYPES[typeKey];
    if (!type) return null;
    const stats = scaleEnemyStats(ENEMY_BASE, type.mods, level);

    const enemy = {
        id: `${typeKey}_lvl${level}_${Date.now()}`,
        name: `${type.name} (Lvl ${level})`,
        level: level,
        type: typeKey,
        attributes: {
            KK: stats.KK,
            GE: stats.GE,
            IN: stats.IN,
            KB: stats.KB,
            VE: stats.VE
        },
        vital: {
            life: stats.life,
            maxLife: stats.life,
            stamina: stats.stamina,
            maxStamina: stats.stamina
        },
        combat: {
            attack: stats.attack,
            defense: stats.defense,
            armor: stats.armor
        },
        abilities: type.abilities,
        lootTable: type.loot
    };

    // Kompat mit Kampfengine-Modell
    enemy.life = enemy.vital.life;
    enemy.damage = enemy.combat.attack;
    enemy.hitChance = 50 + Math.floor(enemy.combat.attack / 2);
    enemy.evasion = Math.floor(enemy.attributes.GE / 2);

    return enemy;
}

function generateLoot(enemy) {
    const loot = [];
    (enemy.lootTable || []).forEach(entry => {
        const roll = Math.random() * 100;
        if (roll < entry.chance) {
            loot.push(entry.id);
        }
    });
    return loot;
}

/* UI: Level- & Typ-Auswahl – nutzt startCombat aus Modul 7 */

let selectedEnemyLevel = null;

function openEnemyLevelMenu() {
    const popup = document.getElementById("enemy-level-popup");
    if (popup) popup.classList.remove("hidden");
}

function closeEnemyLevelMenu() {
    const popup = document.getElementById("enemy-level-popup");
    if (popup) popup.classList.add("hidden");
}

function chooseEnemyLevel(level) {
    selectedEnemyLevel = level;
    closeEnemyLevelMenu();
    openEnemyTypeMenu();
}

function openEnemyTypeMenu() {
    const popup = document.getElementById("enemy-type-popup");
    if (popup) popup.classList.remove("hidden");
}

function closeEnemyTypeMenu() {
    const popup = document.getElementById("enemy-type-popup");
    if (popup) popup.classList.add("hidden");
}

function chooseEnemyType(typeKey) {
    const enemy = generateEnemy(selectedEnemyLevel || 1, typeKey);
    currentEnemy = enemy;
    closeEnemyTypeMenu();
    startCombat(enemy);
}

function onEnemyDefeated(enemy) {
    grantSP(1, "Gegner besiegt");
    const loot = generateLoot(enemy);
    if (loot.length > 0) {
        addLoot(loot);
        appendCombatLog("Beute erhalten!");
    }
}

/* ============================================================
   MODUL 13 — WELT- & ZONEN-SYSTEM (nutzt generateEnemy/startCombat)
============================================================ */

const zoneLibrary = {
    forest: {
        id: "forest",
        name: "Dunkelwald",
        levelRange: { min: 1, max: 5 },
        types: { beast: 60, humanoid: 20, undead: 10, demon: 10 },
        encounterChance: 40,
        travelTime: 5,
        danger: "Mittel",
        description: "Ein dichter, feuchter Wald voller Gefahren.",
        events: ["herb_find", "wolf_tracks"]
    },
    ruins: {
        id: "ruins",
        name: "Verfallene Ruinen",
        levelRange: { min: 3, max: 8 },
        types: { undead: 50, demon: 20, humanoid: 20, beast: 10 },
        encounterChance: 50,
        travelTime: 8,
        danger: "Hoch",
        description: "Alte Gemäuer, von der Zeit und dunklen Mächten gezeichnet.",
        events: ["trap", "knowledge_test"]
    },
    plains: {
        id: "plains",
        name: "Weite Ebenen",
        levelRange: { min: 1, max: 4 },
        types: { humanoid: 40, beast: 40, undead: 10, demon: 10 },
        encounterChance: 30,
        travelTime: 4,
        danger: "Niedrig",
        description: "Offenes Land mit vereinzelten Wegen und Reisenden.",
        events: ["merchant", "herb_find"]
    },
    swamp: {
        id: "swamp",
        name: "Sumpfland",
        levelRange: { min: 4, max: 9 },
        types: { beast: 40, undead: 30, demon: 20, humanoid: 10 },
        encounterChance: 45,
        travelTime: 7,
        danger: "Mittel",
        description: "Nebel, faulige Gewässer und verborgene Gefahren.",
        events: ["trap", "herb_find"]
    }
};

const zoneEvents = {
    herb_find: {
        id: "herb_find",
        type: "probe",
        description: "Du entdeckst etwas im Unterholz – vielleicht nützliche Kräuter.",
        attribute: "IN",
        difficulty: 12,
        reward: { item: "healingHerb" }
    },
    wolf_tracks: {
        id: "wolf_tracks",
        type: "probe",
        description: "Du findest frische Spuren – vielleicht ein Rudel in der Nähe.",
        attribute: "IN",
        difficulty: 10,
        reward: { encounter: { type: "beast" } }
    },
    trap: {
        id: "trap",
        type: "probe",
        description: "Du stolperst beinahe über eine verborgene Falle.",
        attribute: "GE",
        difficulty: 14,
        reward: { avoidDamage: true }
    },
    knowledge_test: {
        id: "knowledge_test",
        type: "probe",
        description: "Alte Runen zieren eine Mauer. Kannst du sie deuten?",
        attribute: "IN",
        difficulty: 15,
        reward: { spBonus: 1 }
    },
    merchant: {
        id: "merchant",
        type: "event",
        description: "Ein reisender Händler kreuzt deinen Weg.",
        action: function () {
            appendTravelLog("Ein Händler ist in der Nähe – Handel ist möglich.");
            // hier könntest du openMerchant(...) triggern
        }
    }
};

let currentZone = null;
let currentZoneEvent = null;

function openTravelMenu() {
    const popup = document.getElementById("travel-popup");
    const list = document.getElementById("travel-zone-list");
    if (!popup || !list) return;
    list.innerHTML = "";
    Object.keys(zoneLibrary).forEach(zoneId => {
        const zone = zoneLibrary[zoneId];
        const btn = document.createElement("button");
        btn.textContent =
            `${zone.name} (Lvl ${zone.levelRange.min}-${zone.levelRange.max}, Gefahr: ${zone.danger})`;
        btn.onclick = () => openZoneConfirm(zoneId);
        list.appendChild(btn);
    });
    popup.classList.remove("hidden");
}

function closeTravelMenu() {
    const popup = document.getElementById("travel-popup");
    if (popup) popup.classList.add("hidden");
}

function openZoneConfirm(zoneId) {
    const zone = zoneLibrary[zoneId];
    const confirmPopup = document.getElementById("travel-confirm-popup");
    if (!confirmPopup || !zone) return;
    document.getElementById("travel-confirm-name").textContent = zone.name;
    document.getElementById("travel-confirm-time").textContent = zone.travelTime;
    document.getElementById("travel-confirm-danger").textContent = zone.danger;
    document.getElementById("travel-confirm-desc").textContent = zone.description;
    confirmPopup.dataset.zoneId = zoneId;
    confirmPopup.classList.remove("hidden");
}

function closeZoneConfirm() {
    const confirmPopup = document.getElementById("travel-confirm-popup");
    if (confirmPopup) confirmPopup.classList.add("hidden");
}

function confirmTravel() {
    const confirmPopup = document.getElementById("travel-confirm-popup");
    if (!confirmPopup) return;
    const zoneId = confirmPopup.dataset.zoneId;
    const zone = zoneLibrary[zoneId];
    if (!zone) return;
    currentZone = zone;
    closeZoneConfirm();
    closeTravelMenu();
    appendTravelLog(`Du reist nach ${zone.name}.`);
    grantSP(1, "Reise");
    resolveTravelOutcome(zone);
}

function resolveTravelOutcome(zone) {
    const roll = Math.random() * 100;
    if (roll < zone.encounterChance) {
        const typeKey = chooseEnemyTypeForZone(zone);
        const level = randomInt(zone.levelRange.min, zone.levelRange.max);
        const enemy = generateEnemy(level, typeKey);
        appendTravelLog(`Ein ${enemy.name} stellt sich dir in ${zone.name} in den Weg!`);
        currentEnemy = enemy;
        startCombat(enemy);
    } else {
        if (zone.events && zone.events.length > 0) {
            const eventId = randomFromArray(zone.events);
            triggerZoneEvent(eventId);
        } else {
            appendTravelLog(`Du erreichst dein Ziel in ${zone.name} ohne besondere Vorkommnisse.`);
        }
    }
}

function chooseEnemyTypeForZone(zone) {
    const types = zone.types;
    const roll = Math.random() * 100;
    let sum = 0;
    for (const key in types) {
        sum += types[key];
        if (roll < sum) return key;
    }
    return "humanoid";
}

function triggerZoneEvent(eventId) {
    const event = zoneEvents[eventId];
    if (!event) {
        appendTravelLog("Etwas passiert, aber es ist noch nicht definiert.");
        return;
    }
    if (event.type === "probe") {
        openZoneProbePopup(event);
    } else if (event.type === "event" && typeof event.action === "function") {
        appendTravelLog(event.description);
        event.action();
    }
}

function openZoneProbePopup(event) {
    currentZoneEvent = event;
    const popup = document.getElementById("zone-probe-popup");
    if (!popup) return;
    document.getElementById("zone-probe-desc").textContent = event.description;
    document.getElementById("zone-probe-attr").textContent = event.attribute;
    document.getElementById("zone-probe-diff").textContent = event.difficulty;
    popup.classList.remove("hidden");
}

function closeZoneProbePopup() {
    const popup = document.getElementById("zone-probe-popup");
    if (popup) popup.classList.add("hidden");
    currentZoneEvent = null;
}

function performZoneEventProbe() {
    if (!currentZoneEvent) return;
    const attr = currentZoneEvent.attribute;
    const diff = currentZoneEvent.difficulty;
    const result = performAttributeProbe(attr, 0, diff);
    if (result.success) {
        appendTravelLog("Die Probe gelingt.");
        if (currentZoneEvent.reward) {
            handleZoneEventReward(currentZoneEvent.reward);
        }
        grantSP(1, "Zonen-Event erfolgreich");
    } else {
        appendTravelLog("Die Probe misslingt.");
    }
    closeZoneProbePopup();
}

function handleZoneEventReward(reward) {
    if (reward.item) {
        addItem(reward.item);
        appendTravelLog(`Du erhältst: ${itemLibrary[reward.item].name}.`);
    }
    if (reward.encounter) {
        const typeKey = reward.encounter.type || "humanoid";
        const zone = currentZone || zoneLibrary.forest;
        const level = randomInt(zone.levelRange.min, zone.levelRange.max);
        const enemy = generateEnemy(level, typeKey);
        appendTravelLog(`Durch das Ereignis wird ein ${enemy.name} auf dich aufmerksam.`);
        currentEnemy = enemy;
        startCombat(enemy);
    }
    if (reward.spBonus) {
        grantSP(reward.spBonus, "Zonen-Eventbonus");
        appendTravelLog(`Du erhältst zusätzlich ${reward.spBonus} SP.`);
    }
    if (reward.avoidDamage) {
        appendTravelLog("Du entgehst knapp einer Falle und bleibst unverletzt.");
    }
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomFromArray(arr) {
    if (!arr || arr.length === 0) return null;
    const index = Math.floor(Math.random() * arr.length);
    return arr[index];
}
</script>
</body>
</html>
